; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\key.o --asm_dir=..\ --list_dir=..\ --depend=..\key.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\FWLIB\inc -I..\SYSTEM\INC -IG:\uart-NVIC\USER\RTE -IH:\mdk5.14\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IH:\mdk5.14\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\key.crf ..\SYSTEM\SRC\key.c]
                          THUMB

                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI0_IRQHandler PROC
;;;179    // 外部中断线 0 的中断处理程序
;;;180    void EXTI0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;181    {
;;;182    	// ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
;;;183    	// void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
;;;184    	// 此处完全可以不作以下判断，但如果是 EXTI[9:5] 或 EXTI[15:10] 上的中断则必须判断
;;;185    	if (EXTI_GetITStatus(EXTI_Line0))   
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b160              CBZ      r0,|L1.36|
;;;186    	{
;;;187    		uint32_t count = 168000000 / 5 / 4;
00000a  4808              LDR      r0,|L1.44|
;;;188    		key_value |= KEY_0;
00000c  4908              LDR      r1,|L1.48|
00000e  7809              LDRB     r1,[r1,#0]  ; key_value
000010  f0410101          ORR      r1,r1,#1
000014  4a06              LDR      r2,|L1.48|
000016  7011              STRB     r1,[r2,#0]
;;;189    		while (count--);
000018  bf00              NOP      
                  |L1.26|
00001a  0001              MOVS     r1,r0
00001c  f1a00001          SUB      r0,r0,#1
000020  d1fb              BNE      |L1.26|
;;;190    	}
000022  bf00              NOP      
                  |L1.36|
;;;191    	// 清除中断标志
;;;192    	EXTI_ClearITPendingBit(EXTI_Line0);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       EXTI_ClearITPendingBit
;;;193    }
00002a  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  |L1.44|
                          DCD      0x00802c80
                  |L1.48|
                          DCD      key_value

                          AREA ||i.EXTI2_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI2_IRQHandler PROC
;;;195    // 外部中断线 2 的中断处理程序
;;;196    void EXTI2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198    	uint32_t count = 168000000 / 5 / 4;
000002  4c08              LDR      r4,|L2.36|
;;;199    	key_value |= KEY_1;
000004  4808              LDR      r0,|L2.40|
000006  7800              LDRB     r0,[r0,#0]  ; key_value
000008  f0400002          ORR      r0,r0,#2
00000c  4906              LDR      r1,|L2.40|
00000e  7008              STRB     r0,[r1,#0]
;;;200    	while (count--);
000010  bf00              NOP      
                  |L2.18|
000012  0020              MOVS     r0,r4
000014  f1a40401          SUB      r4,r4,#1
000018  d1fb              BNE      |L2.18|
;;;201    	
;;;202    	// 清除中断标志
;;;203    	EXTI_ClearITPendingBit(EXTI_Line2);
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;204    }
000020  bd10              POP      {r4,pc}
;;;205    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x00802c80
                  |L2.40|
                          DCD      key_value

                          AREA ||i.EXTI3_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI3_IRQHandler PROC
;;;206    // 外部中断线 3 的中断处理程序
;;;207    void EXTI3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;208    {
;;;209    	uint32_t count = 168000000 / 5 / 4;
000002  4c08              LDR      r4,|L3.36|
;;;210    	key_value |= KEY_2;
000004  4808              LDR      r0,|L3.40|
000006  7800              LDRB     r0,[r0,#0]  ; key_value
000008  f0400004          ORR      r0,r0,#4
00000c  4906              LDR      r1,|L3.40|
00000e  7008              STRB     r0,[r1,#0]
;;;211    	while (count--);
000010  bf00              NOP      
                  |L3.18|
000012  0020              MOVS     r0,r4
000014  f1a40401          SUB      r4,r4,#1
000018  d1fb              BNE      |L3.18|
;;;212    	
;;;213    	// 清除中断标志
;;;214    	EXTI_ClearITPendingBit(EXTI_Line3);
00001a  2008              MOVS     r0,#8
00001c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;215    }
000020  bd10              POP      {r4,pc}
;;;216    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x00802c80
                  |L3.40|
                          DCD      key_value

                          AREA ||i.EXTI4_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI4_IRQHandler PROC
;;;217    // 外部中断线 4 的中断处理程序
;;;218    void EXTI4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;219    {
;;;220    	uint32_t count = 168000000 / 5 / 4;
000002  4c08              LDR      r4,|L4.36|
;;;221    	key_value |= KEY_3;
000004  4808              LDR      r0,|L4.40|
000006  7800              LDRB     r0,[r0,#0]  ; key_value
000008  f0400008          ORR      r0,r0,#8
00000c  4906              LDR      r1,|L4.40|
00000e  7008              STRB     r0,[r1,#0]
;;;222    	while (count--);
000010  bf00              NOP      
                  |L4.18|
000012  0020              MOVS     r0,r4
000014  f1a40401          SUB      r4,r4,#1
000018  d1fb              BNE      |L4.18|
;;;223    	
;;;224    	// 清除中断标志
;;;225    	EXTI_ClearITPendingBit(EXTI_Line4);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;226    }
000020  bd10              POP      {r4,pc}
;;;227    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x00802c80
                  |L4.40|
                          DCD      key_value

                          AREA ||i.key_init||, CODE, READONLY, ALIGN=2

                  key_init PROC
;;;29      **/
;;;30     void key_init(void)
000000  b500              PUSH     {lr}
;;;31     {
000002  b085              SUB      sp,sp,#0x14
;;;32     	GPIO_InitTypeDef GPIO_InitStruct;
;;;33     #ifdef KEY_USE_INTERRUPT
;;;34     	EXTI_InitTypeDef EXTI_InitStruct;
;;;35     	NVIC_InitTypeDef NVIC_InitStruct;
;;;36     #endif
;;;37     	
;;;38     	// 使能 GPIOA, GPIOE 的时钟
;;;39     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOE, ENABLE);
000004  2101              MOVS     r1,#1
000006  2011              MOVS     r0,#0x11
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;40     	
;;;41     	// 配置 PA0
;;;42     	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN;
00000c  2000              MOVS     r0,#0
00000e  f88d0010          STRB     r0,[sp,#0x10]
;;;43     	// GPIO_OType 和 GPIO_Speed 只有在模式为输出/复用时才需要配置，因此此处不需要配置
;;;44     	//GPIO_InitStruct.GPIO_OType = ;
;;;45     	//GPIO_InitStruct.GPIO_Speed = ;
;;;46     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;
000012  2001              MOVS     r0,#1
000014  9003              STR      r0,[sp,#0xc]
;;;47     	// 此处由于外部存在强上拉/下拉，因此可以配置为任意 --> 浮空/上拉/下拉：
;;;48     	// GPIO_PuPd_NOPULL, GPIO_PuPd_UP, GPIO_PuPd_DOWN 三者任意一个都可以
;;;49     	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
000016  2000              MOVS     r0,#0
000018  f88d0013          STRB     r0,[sp,#0x13]
;;;50     	GPIO_Init(GPIOA, &GPIO_InitStruct);
00001c  a903              ADD      r1,sp,#0xc
00001e  4831              LDR      r0,|L5.228|
000020  f7fffffe          BL       GPIO_Init
;;;51     	
;;;52     	// 配置 PE2, PE3, PE4
;;;53     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;
000024  201c              MOVS     r0,#0x1c
000026  9003              STR      r0,[sp,#0xc]
;;;54     	GPIO_Init(GPIOE, &GPIO_InitStruct);
000028  a903              ADD      r1,sp,#0xc
00002a  482f              LDR      r0,|L5.232|
00002c  f7fffffe          BL       GPIO_Init
;;;55     
;;;56     #ifdef KEY_USE_INTERRUPT
;;;57     	// 配置外部中断线的 NVIC
;;;58     	NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn;
000030  2006              MOVS     r0,#6
000032  f88d0000          STRB     r0,[sp,#0]
;;;59     	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
000036  2001              MOVS     r0,#1
000038  f88d0003          STRB     r0,[sp,#3]
;;;60     	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2;
00003c  2002              MOVS     r0,#2
00003e  f88d0001          STRB     r0,[sp,#1]
;;;61     	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;
000042  f88d0002          STRB     r0,[sp,#2]
;;;62     	NVIC_Init(&NVIC_InitStruct);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       NVIC_Init
;;;63     	
;;;64     	NVIC_InitStruct.NVIC_IRQChannel = EXTI2_IRQn;
00004c  2008              MOVS     r0,#8
00004e  f88d0000          STRB     r0,[sp,#0]
;;;65     	NVIC_Init(&NVIC_InitStruct);
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       NVIC_Init
;;;66     	
;;;67     	NVIC_InitStruct.NVIC_IRQChannel = EXTI3_IRQn;
000058  2009              MOVS     r0,#9
00005a  f88d0000          STRB     r0,[sp,#0]
;;;68     	NVIC_Init(&NVIC_InitStruct);
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       NVIC_Init
;;;69     	
;;;70     	NVIC_InitStruct.NVIC_IRQChannel = EXTI4_IRQn;
000064  200a              MOVS     r0,#0xa
000066  f88d0000          STRB     r0,[sp,#0]
;;;71     	NVIC_Init(&NVIC_InitStruct);
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       NVIC_Init
;;;72     	
;;;73     	// 使能 SYSCFG 时钟，以配置外部中断线与 GPIO 的连接
;;;74     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000070  2101              MOVS     r1,#1
000072  0388              LSLS     r0,r1,#14
000074  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;75     	// 使能 EXTI 时钟
;;;76     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_EXTIT, ENABLE);
000078  2101              MOVS     r1,#1
00007a  03c8              LSLS     r0,r1,#15
00007c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;77     	
;;;78     	// void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
;;;79     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0);
000080  2100              MOVS     r1,#0
000082  4608              MOV      r0,r1
000084  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;80     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource2);
000088  2102              MOVS     r1,#2
00008a  2004              MOVS     r0,#4
00008c  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;81     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource3);
000090  2103              MOVS     r1,#3
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;82     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource4);
000098  2104              MOVS     r1,#4
00009a  4608              MOV      r0,r1
00009c  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;83     	// 这里已经使用完了 SYSCFG，因此可以关闭它的时钟
;;;84     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  f44f4080          MOV      r0,#0x4000
0000a6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;85     	
;;;86     	EXTI_InitStruct.EXTI_Line = EXTI_Line0 | EXTI_Line2 | EXTI_Line3 | EXTI_Line4;
0000aa  201d              MOVS     r0,#0x1d
0000ac  9001              STR      r0,[sp,#4]
;;;87     	EXTI_InitStruct.EXTI_LineCmd = ENABLE;
0000ae  2001              MOVS     r0,#1
0000b0  f88d000a          STRB     r0,[sp,#0xa]
;;;88     	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;      // 用于中断
0000b4  2000              MOVS     r0,#0
0000b6  f88d0008          STRB     r0,[sp,#8]
;;;89     	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;  // 下降沿触发(按下时触发)
0000ba  200c              MOVS     r0,#0xc
0000bc  f88d0009          STRB     r0,[sp,#9]
;;;90     	// void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
;;;91     	EXTI_Init(&EXTI_InitStruct);
0000c0  a801              ADD      r0,sp,#4
0000c2  f7fffffe          BL       EXTI_Init
;;;92     	
;;;93     	// ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
;;;94     	// void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
;;;95     	EXTI_ClearITPendingBit(EXTI_Line0);
0000c6  2001              MOVS     r0,#1
0000c8  f7fffffe          BL       EXTI_ClearITPendingBit
;;;96     	EXTI_ClearITPendingBit(EXTI_Line2);
0000cc  2004              MOVS     r0,#4
0000ce  f7fffffe          BL       EXTI_ClearITPendingBit
;;;97     	EXTI_ClearITPendingBit(EXTI_Line3);
0000d2  2008              MOVS     r0,#8
0000d4  f7fffffe          BL       EXTI_ClearITPendingBit
;;;98     	EXTI_ClearITPendingBit(EXTI_Line4);
0000d8  2010              MOVS     r0,#0x10
0000da  f7fffffe          BL       EXTI_ClearITPendingBit
;;;99     #endif
;;;100    	
;;;101    }
0000de  b005              ADD      sp,sp,#0x14
0000e0  bd00              POP      {pc}
;;;102    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L5.228|
                          DCD      0x40020000
                  |L5.232|
                          DCD      0x40021000

                          AREA ||i.key_pressed||, CODE, READONLY, ALIGN=1

                  key_pressed PROC
;;;171     **/
;;;172    uint8_t key_pressed(uint8_t key_state, uint8_t key)
000000  4602              MOV      r2,r0
;;;173    {
;;;174    	return ((key_state & 0xF) & (key & 0xF)) != 0;
000002  f001000f          AND      r0,r1,#0xf
000006  4010              ANDS     r0,r0,r2
000008  b108              CBZ      r0,|L6.14|
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;175    }
00000c  4770              BX       lr
                  |L6.14|
00000e  2000              MOVS     r0,#0                 ;174
000010  e7fc              B        |L6.12|
;;;176    
                          ENDP


                          AREA ||i.key_scan||, CODE, READONLY, ALIGN=2

                  key_scan PROC
;;;151    
;;;152    uint8_t key_scan(uint8_t flag)
000000  4601              MOV      r1,r0
;;;153    {
;;;154    	uint8_t key_state = 0;
000002  2000              MOVS     r0,#0
;;;155    	
;;;156    	// 获取中断中的按键状态
;;;157    	key_state = key_value;
000004  4a02              LDR      r2,|L7.16|
000006  7810              LDRB     r0,[r2,#0]  ; key_value
;;;158    	// 清除中断中的按键状态
;;;159    	key_value = 0;
000008  2200              MOVS     r2,#0
00000a  4b01              LDR      r3,|L7.16|
00000c  701a              STRB     r2,[r3,#0]
;;;160    	
;;;161    	return key_state;
;;;162    }
00000e  4770              BX       lr
;;;163    
                          ENDP

                  |L7.16|
                          DCD      key_value

                          AREA ||.data||, DATA, ALIGN=0

                  key_value
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\SRC\\key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_key_init____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___5_key_c_key_init____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_key_init____REVSH|
#line 153
|__asm___5_key_c_key_init____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_key_init____RRX|
#line 328
|__asm___5_key_c_key_init____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
