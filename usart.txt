; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\usart.o --asm_dir=..\ --list_dir=..\ --depend=..\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\FWLIB\inc -I..\SYSTEM\INC -IG:\uart-NVIC\USER\RTE -IH:\mdk5.14\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IH:\mdk5.14\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\usart.crf ..\SYSTEM\SRC\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;153    // USART1 中断处理(服务)函数
;;;154    void USART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {
;;;156    	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;157    	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;158    	if (SET == USART_GetITStatus(USART1, USART_IT_RXNE))  // 是接收非空中断
000002  f2405125          MOV      r1,#0x525
000006  4825              LDR      r0,|L1.156|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d144              BNE      |L1.154|
;;;159    	{ 
;;;160    		int flag= 0;
000010  2500              MOVS     r5,#0
;;;161    		flag = scanfData(); 	//这个放在中断处理函数中
000012  f7fffffe          BL       scanfData
000016  4605              MOV      r5,r0
;;;162      	//测试协议
;;;163    		if(flag == -1)
000018  1c68              ADDS     r0,r5,#1
00001a  b9b0              CBNZ     r0,|L1.74|
;;;164    		{
;;;165    			int i,j;
;;;166    			//蜂鸣器响1声
;;;167    			BEEP_ON();
00001c  bf00              NOP      
00001e  2201              MOVS     r2,#1
000020  4b1f              LDR      r3,|L1.160|
000022  601a              STR      r2,[r3,#0]
000024  bf00              NOP      
;;;168    			for(i=0;i<0xffff;i++)
000026  2000              MOVS     r0,#0
000028  e005              B        |L1.54|
                  |L1.42|
;;;169    				for(j=0;j<0xff;j++);	
00002a  2100              MOVS     r1,#0
00002c  e000              B        |L1.48|
                  |L1.46|
00002e  1c49              ADDS     r1,r1,#1
                  |L1.48|
000030  29ff              CMP      r1,#0xff
000032  dbfc              BLT      |L1.46|
000034  1c40              ADDS     r0,r0,#1              ;168
                  |L1.54|
000036  f64f72ff          MOV      r2,#0xffff            ;168
00003a  4290              CMP      r0,r2                 ;168
00003c  dbf5              BLT      |L1.42|
;;;170    			BEEP_OFF();
00003e  bf00              NOP      
000040  2200              MOVS     r2,#0
000042  4b17              LDR      r3,|L1.160|
000044  601a              STR      r2,[r3,#0]
000046  bf00              NOP      
;;;171    		}
000048  e021              B        |L1.142|
                  |L1.74|
;;;172    		else if(flag == 1)
00004a  2d01              CMP      r5,#1
00004c  d11f              BNE      |L1.142|
;;;173    		{
;;;174    			int i;
;;;175    			//协议正确完全无误
;;;176    			LED0_ON();
00004e  bf00              NOP      
000050  0269              LSLS     r1,r5,#9
000052  4814              LDR      r0,|L1.164|
000054  f7fffffe          BL       GPIO_ResetBits
000058  bf00              NOP      
;;;177    			LED1_ON();
00005a  bf00              NOP      
00005c  02a9              LSLS     r1,r5,#10
00005e  4811              LDR      r0,|L1.164|
000060  f7fffffe          BL       GPIO_ResetBits
000064  bf00              NOP      
;;;178    			LED2_ON();
000066  bf00              NOP      
000068  0369              LSLS     r1,r5,#13
00006a  480f              LDR      r0,|L1.168|
00006c  f7fffffe          BL       GPIO_ResetBits
000070  bf00              NOP      
;;;179    			LED3_ON();
000072  bf00              NOP      
000074  03a9              LSLS     r1,r5,#14
000076  480c              LDR      r0,|L1.168|
000078  f7fffffe          BL       GPIO_ResetBits
00007c  bf00              NOP      
;;;180    			for(i=0;i<0xffff;i++);
00007e  2400              MOVS     r4,#0
000080  e000              B        |L1.132|
                  |L1.130|
000082  1c64              ADDS     r4,r4,#1
                  |L1.132|
000084  f64f70ff          MOV      r0,#0xffff
000088  4284              CMP      r4,r0
00008a  dbfa              BLT      |L1.130|
;;;181    					 
;;;182    		}
00008c  bf00              NOP      
                  |L1.142|
;;;183    		
;;;184     		USART_ClearITPendingBit(USART1, USART_IT_RXNE); 
00008e  f2405125          MOV      r1,#0x525
000092  4802              LDR      r0,|L1.156|
000094  f7fffffe          BL       USART_ClearITPendingBit
;;;185    	}
000098  bf00              NOP      
                  |L1.154|
;;;186    }
00009a  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

                  |L1.156|
                          DCD      0x40011000
                  |L1.160|
                          DCD      0x424282a0
                  |L1.164|
                          DCD      0x40021400
                  |L1.168|
                          DCD      0x40021000

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;246    
;;;247    void _sys_exit(int return_code) {
000000  bf00              NOP      
                  |L2.2|
;;;248      while (1);    /* endless loop */
000002  e7fe              B        |L2.2|
;;;249    }
;;;250    
                          ENDP


                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;240    
;;;241    void _ttywrch(int ch) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;242      //sendchar (ch);
;;;243    	usart1_putchar(ch);          // 用 usart1 的函数替换
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       usart1_putchar
;;;244    }
00000a  bd10              POP      {r4,pc}
;;;245    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;234    
;;;235    int ferror(FILE *f) {
000000  4601              MOV      r1,r0
;;;236      /* Your implementation of ferror */
;;;237      return EOF;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;238    }
000006  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;228    
;;;229    int fgetc(FILE *f) {
000000  b500              PUSH     {lr}
000002  4603              MOV      r3,r0
;;;230      //return (sendchar(getkey()));
;;;231    	return usart1_getchar();     // 用 usart1 的函数替换
000004  f7fffffe          BL       usart1_getchar
;;;232    }
000008  bd00              POP      {pc}
;;;233    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;223    
;;;224    int fputc(int ch, FILE *f) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;225      //return (sendchar(ch));
;;;226    	return usart1_putchar(ch);   // 用 usart1 的函数替换
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       usart1_putchar
;;;227    }
00000c  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP


                          AREA ||i.usart1_getchar||, CODE, READONLY, ALIGN=2

                  usart1_getchar PROC
;;;108     **/
;;;109    int usart1_getchar(void)
000000  2000              MOVS     r0,#0
;;;110    {
;;;111    	uint16_t ch = 0;
;;;112    	
;;;113    
;;;114    	while (usart1_recv_flag == 0);   // 等待数据
000002  bf00              NOP      
                  |L7.4|
000004  4907              LDR      r1,|L7.36|
000006  6809              LDR      r1,[r1,#0]  ; usart1_recv_flag
000008  2900              CMP      r1,#0
00000a  d0fb              BEQ      |L7.4|
;;;115    	ch = usart1_recv_ch;    // 读取数据
00000c  4906              LDR      r1,|L7.40|
00000e  6809              LDR      r1,[r1,#0]  ; usart1_recv_ch
000010  b288              UXTH     r0,r1
;;;116    	usart1_recv_ch = EOF;   // 清空数据
000012  f04f31ff          MOV      r1,#0xffffffff
000016  4a04              LDR      r2,|L7.40|
000018  6011              STR      r1,[r2,#0]  ; usart1_recv_ch
;;;117    	usart1_recv_flag = 0;   // 清空标志
00001a  2100              MOVS     r1,#0
00001c  4a01              LDR      r2,|L7.36|
00001e  6011              STR      r1,[r2,#0]  ; usart1_recv_flag
;;;118    
;;;119    	
;;;120    	
;;;121    	// 返回数据
;;;122    	return ch;
;;;123    }
000020  4770              BX       lr
;;;124    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      usart1_recv_flag
                  |L7.40|
                          DCD      usart1_recv_ch

                          AREA ||i.usart1_init||, CODE, READONLY, ALIGN=2

                  usart1_init PROC
;;;45      **/
;;;46     void usart1_init(uint32_t baudrate)
000000  b510              PUSH     {r4,lr}
;;;47     {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;48     	GPIO_InitTypeDef GPIO_InitStruct;
;;;49     	USART_InitTypeDef USART_InitStruct;
;;;50     	NVIC_InitTypeDef NVIC_InitStruct;
;;;51     
;;;52     	
;;;53     	// 使能 GPIOA 的时钟
;;;54     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;55     	
;;;56     	// 使能 USART1 的时钟
;;;57     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2010              MOVS     r0,#0x10
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;58     	
;;;59     	// 设置 PA9, PA10 复用为 USART1
;;;60     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000016  2207              MOVS     r2,#7
000018  2109              MOVS     r1,#9
00001a  4826              LDR      r0,|L8.180|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;61     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
000020  2207              MOVS     r2,#7
000022  210a              MOVS     r1,#0xa
000024  4823              LDR      r0,|L8.180|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;62     	
;;;63     	// 配置 PA9, PA10
;;;64     	GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_AF;              // 复用功能
00002a  2002              MOVS     r0,#2
00002c  f88d001c          STRB     r0,[sp,#0x1c]
;;;65     	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;             // 推挽
000030  2000              MOVS     r0,#0
000032  f88d001e          STRB     r0,[sp,#0x1e]
;;;66     	GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_9 | GPIO_Pin_10;
000036  f44f60c0          MOV      r0,#0x600
00003a  9006              STR      r0,[sp,#0x18]
;;;67     	GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_UP;              // 上拉，高电平空闲
00003c  2001              MOVS     r0,#1
00003e  f88d001f          STRB     r0,[sp,#0x1f]
;;;68     	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
000042  2003              MOVS     r0,#3
000044  f88d001d          STRB     r0,[sp,#0x1d]
;;;69     	GPIO_Init(GPIOA, &GPIO_InitStruct);
000048  a906              ADD      r1,sp,#0x18
00004a  481a              LDR      r0,|L8.180|
00004c  f7fffffe          BL       GPIO_Init
;;;70     	
;;;71     	// 配置 USART1
;;;72     	// void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
;;;73     	USART_InitStruct.USART_BaudRate            = baudrate;    // 波特率
000050  9402              STR      r4,[sp,#8]
;;;74     	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  // 无流控
000052  2000              MOVS     r0,#0
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;75     	USART_InitStruct.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;   // 收发
000058  200c              MOVS     r0,#0xc
00005a  f8ad0012          STRH     r0,[sp,#0x12]
;;;76     	USART_InitStruct.USART_Parity              = USART_Parity_No;           // 无奇偶校验
00005e  2000              MOVS     r0,#0
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;77     	USART_InitStruct.USART_StopBits            = USART_StopBits_1;          // 1 位停止位
000064  f8ad000e          STRH     r0,[sp,#0xe]
;;;78     	USART_InitStruct.USART_WordLength          = USART_WordLength_8b;       // 8 位数据位
000068  f8ad000c          STRH     r0,[sp,#0xc]
;;;79     	USART_Init(USART1, &USART_InitStruct);
00006c  a902              ADD      r1,sp,#8
00006e  4812              LDR      r0,|L8.184|
000070  f7fffffe          BL       USART_Init
;;;80     	
;;;81     	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;    // 中断向量表位置
000074  2025              MOVS     r0,#0x25
000076  f88d0004          STRB     r0,[sp,#4]
;;;82     	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;      // 使能 NVIC 中断
00007a  2001              MOVS     r0,#1
00007c  f88d0007          STRB     r0,[sp,#7]
;;;83     	// 优先级数字越小优先级越高
;;;84     	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2;   // 抢占优先级
000080  2002              MOVS     r0,#2
000082  f88d0005          STRB     r0,[sp,#5]
;;;85     	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;   // 响应(子/次)优先级
000086  f88d0006          STRB     r0,[sp,#6]
;;;86     	NVIC_Init(&NVIC_InitStruct);
00008a  a801              ADD      r0,sp,#4
00008c  f7fffffe          BL       NVIC_Init
;;;87     	// void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
;;;88     	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;89     	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;90     	USART_ClearITPendingBit(USART1, USART_IT_RXNE);   // 清空接收非空中断
000090  f2405125          MOV      r1,#0x525
000094  4808              LDR      r0,|L8.184|
000096  f7fffffe          BL       USART_ClearITPendingBit
;;;91     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);    // 使能接收非空中断
00009a  2201              MOVS     r2,#1
00009c  f2405125          MOV      r1,#0x525
0000a0  4805              LDR      r0,|L8.184|
0000a2  f7fffffe          BL       USART_ITConfig
;;;92     
;;;93     
;;;94     	// 使能 USART1
;;;95     	// void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
;;;96     	USART_Cmd(USART1, ENABLE);
0000a6  2101              MOVS     r1,#1
0000a8  4803              LDR      r0,|L8.184|
0000aa  f7fffffe          BL       USART_Cmd
;;;97     }
0000ae  b008              ADD      sp,sp,#0x20
0000b0  bd10              POP      {r4,pc}
;;;98     
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      0x40020000
                  |L8.184|
                          DCD      0x40011000

                          AREA ||i.usart1_putchar||, CODE, READONLY, ALIGN=2

                  usart1_putchar PROC
;;;129     **/
;;;130    int usart1_putchar(int c)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132    	// 等待可发送数据（即等待发送数据缓冲区为空）
;;;133    	while (RESET == USART_GetFlagStatus(USART1, USART_FLAG_TXE));
000004  bf00              NOP      
                  |L9.6|
000006  2180              MOVS     r1,#0x80
000008  4805              LDR      r0,|L9.32|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L9.6|
;;;134    	
;;;135    	// 发送数据
;;;136    	USART_SendData(USART1, c);
000012  b2a1              UXTH     r1,r4
000014  4802              LDR      r0,|L9.32|
000016  f7fffffe          BL       USART_SendData
;;;137    	
;;;138    	return c;
00001a  4620              MOV      r0,r4
;;;139    }
00001c  bd10              POP      {r4,pc}
;;;140    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=2

                  usart1_recv_ch
                          DCD      0xffffffff
                  usart1_recv_flag
                          DCD      0x00000000
                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\SRC\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___7_usart_c_d693318e____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____REVSH|
#line 153
|__asm___7_usart_c_d693318e____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____RRX|
#line 328
|__asm___7_usart_c_d693318e____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
