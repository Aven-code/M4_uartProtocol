; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\protocol.o --asm_dir=..\ --list_dir=..\ --depend=..\protocol.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\FWLIB\inc -I..\SYSTEM\INC -IG:\uart-NVIC\USER\RTE -IH:\mdk5.14\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IH:\mdk5.14\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\protocol.crf ..\SYSTEM\SRC\protocol.c]
                          THUMB

                          AREA ||i.generateCheckCode||, CODE, READONLY, ALIGN=1

                  generateCheckCode PROC
;;;129    */
;;;130    u8 generateCheckCode(u8 const *byteArr, u8 len)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;132        u8 sum = 0, i;
000006  2400              MOVS     r4,#0
;;;133        for (i = 0; i < len; i++)
000008  2100              MOVS     r1,#0
00000a  e004              B        |L1.22|
                  |L1.12|
;;;134        {
;;;135            sum += *(byteArr + i);
00000c  5c50              LDRB     r0,[r2,r1]
00000e  4420              ADD      r0,r0,r4
000010  b2c4              UXTB     r4,r0
000012  1c48              ADDS     r0,r1,#1              ;133
000014  b2c1              UXTB     r1,r0                 ;133
                  |L1.22|
000016  4299              CMP      r1,r3                 ;133
000018  dbf8              BLT      |L1.12|
;;;136        }
;;;137        return (0xff - sum + 1);
00001a  f5c47080          RSB      r0,r4,#0x100
00001e  b2c0              UXTB     r0,r0
;;;138    }
000020  bd10              POP      {r4,pc}
;;;139    
                          ENDP


                          AREA ||i.getProport||, CODE, READONLY, ALIGN=1

                  getProport PROC
;;;161     **/
;;;162    u8 getProport(float val)
000000  b500              PUSH     {lr}
;;;163    {
000002  eeb02a40          VMOV.F32 s4,s0
;;;164        u8 ret = val * getStride(24);
000006  2018              MOVS     r0,#0x18
000008  f7fffffe          BL       getStride
00000c  ee200a02          VMUL.F32 s0,s0,s4
000010  eebc0ac0          VCVT.U32.F32 s0,s0
000014  ee100a10          VMOV     r0,s0
000018  b2c1              UXTB     r1,r0
;;;165        return ret;
00001a  4608              MOV      r0,r1
;;;166    }
00001c  bd00              POP      {pc}
;;;167    
                          ENDP


                          AREA ||i.getSrc||, CODE, READONLY, ALIGN=1

                  getSrc PROC
;;;172     **/
;;;173    float getSrc(u8 val)
000000  b500              PUSH     {lr}
;;;174    {
000002  4601              MOV      r1,r0
;;;175        return val / getStride(24);
000004  2018              MOVS     r0,#0x18
000006  f7fffffe          BL       getStride
00000a  eef00a40          VMOV.F32 s1,s0
00000e  ee001a10          VMOV     s0,r1
000012  eeb81a40          VCVT.F32.U32 s2,s0
000016  ee810a20          VDIV.F32 s0,s2,s1
;;;176    }
00001a  bd00              POP      {pc}
                          ENDP


                          AREA ||i.getStride||, CODE, READONLY, ALIGN=2

                  getStride PROC
;;;149     **/
;;;150    float getStride(u8 range)
000000  ed9f1a06          VLDR     s2,|L4.28|
;;;151    {
;;;152        float byte = 255;
000004  eef00a41          VMOV.F32 s1,s2
;;;153        float stride = byte / range; // 得到步长
000008  ee010a10          VMOV     s2,r0
00000c  eeb81a41          VCVT.F32.U32 s2,s2
000010  eec01a81          VDIV.F32 s3,s1,s2
000014  eeb00a61          VMOV.F32 s0,s3
;;;154        return stride;
;;;155    }
000018  4770              BX       lr
;;;156    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
00001c  437f0000          DCFS     0x437f0000 ; 255

                          AREA ||i.isRealCheckCode||, CODE, READONLY, ALIGN=1

                  isRealCheckCode PROC
;;;116    //自己生成的校验码是否匹配的上协议中的，相同返回1，不同返回0
;;;117    int isRealCheckCode(u8 const *arr, u16 length)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;119        if (generateCheckCode(arr, length - 1) == *(arr + length - 1))
000006  1e60              SUBS     r0,r4,#1
000008  b2c1              UXTB     r1,r0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       generateCheckCode
000010  1929              ADDS     r1,r5,r4
000012  f8111c01          LDRB     r1,[r1,#-1]
000016  4288              CMP      r0,r1
000018  d101              BNE      |L5.30|
;;;120            return TRUE;
00001a  2001              MOVS     r0,#1
                  |L5.28|
;;;121        return FALSE;
;;;122    }
00001c  bd30              POP      {r4,r5,pc}
                  |L5.30|
00001e  2000              MOVS     r0,#0                 ;121
000020  e7fc              B        |L5.28|
;;;123    
                          ENDP


                          AREA ||i.parsingAarry||, CODE, READONLY, ALIGN=2

                  parsingAarry PROC
;;;91     
;;;92     int parsingAarry()
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
;;;94         u8 i;
;;;95         u16 src_funcode, len = (receiveDataArray[2] << 8) | receiveDataArray[3];
000002  4813              LDR      r0,|L6.80|
000004  78c0              LDRB     r0,[r0,#3]  ; receiveDataArray
000006  4912              LDR      r1,|L6.80|
000008  7889              LDRB     r1,[r1,#2]  ; receiveDataArray
00000a  ea402601          ORR      r6,r0,r1,LSL #8
;;;96         
;;;97         if (!isRealCheckCode(receiveDataArray, len)) //如果校验码不对，直接返回
00000e  4631              MOV      r1,r6
000010  480f              LDR      r0,|L6.80|
000012  f7fffffe          BL       isRealCheckCode
000016  b908              CBNZ     r0,|L6.28|
;;;98             return FALSE;                            // 0
000018  2000              MOVS     r0,#0
                  |L6.26|
;;;99         src_funcode = (receiveDataArray[5] << 8) | receiveDataArray[6];
;;;100    
;;;101        /*分析数组*/
;;;102        //整一个最省时的查找算法----插值查找，查找功能码数组中的是否存在
;;;103        //先用遍历实现查找，看看效果
;;;104        for (i = 0; i < RECEV_MSGTYPE_MAX; i++)
;;;105        {
;;;106            if (receiveMsgType[i].funcode == src_funcode) //找到相同的
;;;107            {
;;;108                receiveMsgType[i].fun_ptr(); //消息体长度等与 整长度减去8个字节
;;;109                return TRUE;
;;;110            }
;;;111        }
;;;112        return FALSE;
;;;113    }
00001a  bd70              POP      {r4-r6,pc}
                  |L6.28|
00001c  480c              LDR      r0,|L6.80|
00001e  7980              LDRB     r0,[r0,#6]            ;99  ; receiveDataArray
000020  490b              LDR      r1,|L6.80|
000022  7949              LDRB     r1,[r1,#5]            ;99  ; receiveDataArray
000024  ea402501          ORR      r5,r0,r1,LSL #8       ;99
000028  2400              MOVS     r4,#0                 ;104
00002a  e00d              B        |L6.72|
                  |L6.44|
00002c  4809              LDR      r0,|L6.84|
00002e  f8300034          LDRH     r0,[r0,r4,LSL #3]     ;106
000032  42a8              CMP      r0,r5                 ;106
000034  d106              BNE      |L6.68|
000036  4907              LDR      r1,|L6.84|
000038  eb0101c4          ADD      r1,r1,r4,LSL #3       ;108
00003c  6848              LDR      r0,[r1,#4]            ;108
00003e  4780              BLX      r0                    ;108
000040  2001              MOVS     r0,#1                 ;109
000042  e7ea              B        |L6.26|
                  |L6.68|
000044  1c60              ADDS     r0,r4,#1              ;104
000046  b2c4              UXTB     r4,r0                 ;104
                  |L6.72|
000048  2c14              CMP      r4,#0x14              ;104
00004a  dbef              BLT      |L6.44|
00004c  2000              MOVS     r0,#0                 ;112
00004e  e7e4              B        |L6.26|
;;;114    
                          ENDP

                  |L6.80|
                          DCD      receiveDataArray
                  |L6.84|
                          DCD      receiveMsgType

                          AREA ||i.scanfData||, CODE, READONLY, ALIGN=2

                  scanfData PROC
;;;25     //模拟接收数据，
;;;26     int scanfData() //这个放在中断处理函数中
000000  b510              PUSH     {r4,lr}
;;;27     {
;;;28         static u16 i = 0;
;;;29         static u8 rece_flag = 0;
;;;30          
;;;31         if (!rece_flag) //为0表示读引导头，讲引导头放在数组中
000002  4849              LDR      r0,|L7.296|
000004  7800              LDRB     r0,[r0,#0]  ; rece_flag
000006  2800              CMP      r0,#0
000008  d13b              BNE      |L7.130|
;;;32         {
;;;33             receiveDataArray[i] =  USART_ReceiveData(USART1); 
00000a  4848              LDR      r0,|L7.300|
00000c  f7fffffe          BL       USART_ReceiveData
000010  4947              LDR      r1,|L7.304|
000012  4a48              LDR      r2,|L7.308|
000014  8812              LDRH     r2,[r2,#0]  ; i
000016  5488              STRB     r0,[r1,r2]
;;;34     
;;;35             if (i == 0 && receiveDataArray[0] != 0xee)
000018  4846              LDR      r0,|L7.308|
00001a  8800              LDRH     r0,[r0,#0]  ; i
00001c  b980              CBNZ     r0,|L7.64|
00001e  4608              MOV      r0,r1
000020  7800              LDRB     r0,[r0,#0]  ; receiveDataArray
000022  28ee              CMP      r0,#0xee
000024  d00c              BEQ      |L7.64|
;;;36             {
;;;37                 i = 0;
000026  2000              MOVS     r0,#0
000028  4942              LDR      r1,|L7.308|
00002a  8008              STRH     r0,[r1,#0]
;;;38                 rece_flag = 0;                            //下次接收又是读引导头
00002c  493e              LDR      r1,|L7.296|
00002e  7008              STRB     r0,[r1,#0]
;;;39                 memset(receiveDataArray, 0, RECEIVE_MAX); //清空接收数据数组
000030  f44f7180          MOV      r1,#0x100
000034  483e              LDR      r0,|L7.304|
000036  f7fffffe          BL       __aeabi_memclr
;;;40                 return -1;
00003a  f04f30ff          MOV      r0,#0xffffffff
                  |L7.62|
;;;41             }
;;;42             else if (i == 1 && receiveDataArray[1] != 0xee)
;;;43             {
;;;44                 i = 0;
;;;45                 rece_flag = 0;                            //下次接收又是读引导头
;;;46                 memset(receiveDataArray, 0, RECEIVE_MAX); //清空接收数据数组
;;;47                 return -1;
;;;48             }
;;;49     
;;;50             if (i++)
;;;51             {
;;;52                 rece_flag = 1; //表示引导头已读取完成
;;;53             }
;;;54         }
;;;55         else // else 读取剩下的字节
;;;56         {
;;;57             if (i < 4) //这个判断是为了长度，可不可以字节用长度
;;;58             {
;;;59     
;;;60                /*执行到这里说明,引导头都正确，这时候再去得到长度的值,长度占两个字节， 取2次*/
;;;61                receiveDataArray[i++] = USART_ReceiveData(USART1);
;;;62                
;;;63             }
;;;64             else /*当i == 4 时，说明后面就按照 长度-4来循环获取数据*/
;;;65             {
;;;66                 receiveDataArray[i++] = USART_ReceiveData(USART1);
;;;67                 //第九个的下标长度是10，所以i++ 如果== 长度表示这个包已经接收完毕
;;;68                 /*如果长时间没等到来自蓝牙发送的长度，则退出。这里需要创建一个定时器*/
;;;69                 if (i == ((receiveDataArray[2] << 8) | receiveDataArray[3]))
;;;70                 {
;;;71                     u8 sign = parsingAarry(); //调用判断检验码，分析协议的函数,
;;;72                     i = 0;
;;;73                     rece_flag = 0;
;;;74                     memset(receiveDataArray, 0, RECEIVE_MAX); //清空接收数据数组
;;;75                     return sign ? 1 : -1;                     //sign为TRUE表示数据正常结束，为FALSE表示包协议有误 ,返回-1
;;;76                 }
;;;77                 // 反之 如果i 大于了 当前协议的长度，则重新开始,这里加个禁止通信什么的都可以。如果超过三次大于，可以试着重置设备，并告诉用户当前收到干扰
;;;78                 else if (i > ((receiveDataArray[2] << 8) | receiveDataArray[3]))
;;;79                 {
;;;80                     i = 0;
;;;81                     rece_flag = 0;                            //下次接收又是读引导头
;;;82                     memset(receiveDataArray, 0, RECEIVE_MAX); //清空接收数据数组
;;;83                     return -1;
;;;84                 }
;;;85             }
;;;86         }
;;;87         return 0; //返回0，表示继续接收下一个字节
;;;88     }
00003e  bd10              POP      {r4,pc}
                  |L7.64|
000040  483c              LDR      r0,|L7.308|
000042  8800              LDRH     r0,[r0,#0]            ;42  ; i
000044  2801              CMP      r0,#1                 ;42
000046  d110              BNE      |L7.106|
000048  4839              LDR      r0,|L7.304|
00004a  7840              LDRB     r0,[r0,#1]            ;42  ; receiveDataArray
00004c  28ee              CMP      r0,#0xee              ;42
00004e  d00c              BEQ      |L7.106|
000050  2000              MOVS     r0,#0                 ;44
000052  4938              LDR      r1,|L7.308|
000054  8008              STRH     r0,[r1,#0]            ;44
000056  4934              LDR      r1,|L7.296|
000058  7008              STRB     r0,[r1,#0]            ;45
00005a  f44f7180          MOV      r1,#0x100             ;46
00005e  4834              LDR      r0,|L7.304|
000060  f7fffffe          BL       __aeabi_memclr
000064  f04f30ff          MOV      r0,#0xffffffff        ;47
000068  e7e9              B        |L7.62|
                  |L7.106|
00006a  4832              LDR      r0,|L7.308|
00006c  8801              LDRH     r1,[r0,#0]            ;50  ; i
00006e  8800              LDRH     r0,[r0,#0]            ;50  ; i
000070  1c40              ADDS     r0,r0,#1              ;50
000072  4a30              LDR      r2,|L7.308|
000074  8010              STRH     r0,[r2,#0]            ;50
000076  2900              CMP      r1,#0                 ;50
000078  d053              BEQ      |L7.290|
00007a  2001              MOVS     r0,#1                 ;52
00007c  492a              LDR      r1,|L7.296|
00007e  7008              STRB     r0,[r1,#0]            ;52
000080  e04f              B        |L7.290|
                  |L7.130|
000082  482c              LDR      r0,|L7.308|
000084  8800              LDRH     r0,[r0,#0]            ;57  ; i
000086  2804              CMP      r0,#4                 ;57
000088  da0c              BGE      |L7.164|
00008a  4828              LDR      r0,|L7.300|
00008c  f7fffffe          BL       USART_ReceiveData
000090  b2c1              UXTB     r1,r0                 ;61
000092  4828              LDR      r0,|L7.308|
000094  8802              LDRH     r2,[r0,#0]            ;61  ; i
000096  8800              LDRH     r0,[r0,#0]            ;61  ; i
000098  1c40              ADDS     r0,r0,#1              ;61
00009a  4b26              LDR      r3,|L7.308|
00009c  8018              STRH     r0,[r3,#0]            ;61
00009e  4824              LDR      r0,|L7.304|
0000a0  5481              STRB     r1,[r0,r2]            ;61
0000a2  e03e              B        |L7.290|
                  |L7.164|
0000a4  4821              LDR      r0,|L7.300|
0000a6  f7fffffe          BL       USART_ReceiveData
0000aa  b2c2              UXTB     r2,r0                 ;66
0000ac  4821              LDR      r0,|L7.308|
0000ae  8801              LDRH     r1,[r0,#0]            ;66  ; i
0000b0  8800              LDRH     r0,[r0,#0]            ;66  ; i
0000b2  1c40              ADDS     r0,r0,#1              ;66
0000b4  4b1f              LDR      r3,|L7.308|
0000b6  8018              STRH     r0,[r3,#0]            ;66
0000b8  481d              LDR      r0,|L7.304|
0000ba  5442              STRB     r2,[r0,r1]            ;66
0000bc  78c0              LDRB     r0,[r0,#3]            ;69  ; receiveDataArray
0000be  491c              LDR      r1,|L7.304|
0000c0  7889              LDRB     r1,[r1,#2]            ;69  ; receiveDataArray
0000c2  ea402001          ORR      r0,r0,r1,LSL #8       ;69
0000c6  4619              MOV      r1,r3                 ;69
0000c8  8809              LDRH     r1,[r1,#0]            ;69  ; i
0000ca  4288              CMP      r0,r1                 ;69
0000cc  d112              BNE      |L7.244|
0000ce  f7fffffe          BL       parsingAarry
0000d2  b2c4              UXTB     r4,r0                 ;71
0000d4  2000              MOVS     r0,#0                 ;72
0000d6  4917              LDR      r1,|L7.308|
0000d8  8008              STRH     r0,[r1,#0]            ;72
0000da  4913              LDR      r1,|L7.296|
0000dc  7008              STRB     r0,[r1,#0]            ;73
0000de  f44f7180          MOV      r1,#0x100             ;74
0000e2  4813              LDR      r0,|L7.304|
0000e4  f7fffffe          BL       __aeabi_memclr
0000e8  b10c              CBZ      r4,|L7.238|
0000ea  2001              MOVS     r0,#1                 ;75
0000ec  e7a7              B        |L7.62|
                  |L7.238|
0000ee  f04f30ff          MOV      r0,#0xffffffff        ;75
0000f2  e7a4              B        |L7.62|
                  |L7.244|
0000f4  480e              LDR      r0,|L7.304|
0000f6  78c0              LDRB     r0,[r0,#3]            ;78  ; receiveDataArray
0000f8  490d              LDR      r1,|L7.304|
0000fa  7889              LDRB     r1,[r1,#2]            ;78  ; receiveDataArray
0000fc  ea402001          ORR      r0,r0,r1,LSL #8       ;78
000100  490c              LDR      r1,|L7.308|
000102  8809              LDRH     r1,[r1,#0]            ;78  ; i
000104  4288              CMP      r0,r1                 ;78
000106  da0c              BGE      |L7.290|
000108  2000              MOVS     r0,#0                 ;80
00010a  490a              LDR      r1,|L7.308|
00010c  8008              STRH     r0,[r1,#0]            ;80
00010e  4906              LDR      r1,|L7.296|
000110  7008              STRB     r0,[r1,#0]            ;81
000112  f44f7180          MOV      r1,#0x100             ;82
000116  4806              LDR      r0,|L7.304|
000118  f7fffffe          BL       __aeabi_memclr
00011c  f04f30ff          MOV      r0,#0xffffffff        ;83
000120  e78d              B        |L7.62|
                  |L7.290|
000122  2000              MOVS     r0,#0                 ;87
000124  e78b              B        |L7.62|
;;;89     
                          ENDP

000126  0000              DCW      0x0000
                  |L7.296|
                          DCD      rece_flag
                  |L7.300|
                          DCD      0x40011000
                  |L7.304|
                          DCD      receiveDataArray
                  |L7.308|
                          DCD      i

                          AREA ||.data||, DATA, ALIGN=1

                  i
000000  0000              DCW      0x0000
                  rece_flag
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\SRC\\protocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_protocol_c_548b6431____REV16|
#line 138 "..\\CORE\\core_cmInstr.h"
|__asm___10_protocol_c_548b6431____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_protocol_c_548b6431____REVSH|
#line 153
|__asm___10_protocol_c_548b6431____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_protocol_c_548b6431____RRX|
#line 328
|__asm___10_protocol_c_548b6431____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
