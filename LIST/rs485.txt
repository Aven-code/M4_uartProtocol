; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\..\obj\rs485.o --asm_dir=..\..\LIST\ --list_dir=..\..\LIST\ --depend=..\..\obj\rs485.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\..\CORE -I..\..\FWLIB\inc -I..\..\SYSTEM\INC -IF:\粤嵌\课堂演示-粤嵌1914\3_Cortex-M4应用开发\11_I2C总线原理\USER\RTE -IE:\Kile\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IE:\Kile\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\obj\rs485.crf ..\..\SYSTEM\SRC\rs485.c]
                          THUMB

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;144    // USART2 中断处理(服务)函数
;;;145    void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147    	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;148    	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;149    	if (SET == USART_GetITStatus(USART2, USART_IT_RXNE))  // 是接收非空中断
000002  f2405125          MOV      r1,#0x525
000006  4809              LDR      r0,|L1.44|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d10c              BNE      |L1.42|
;;;150    	{
;;;151    		rs485_recv_ch = USART_ReceiveData(USART2);
000010  4806              LDR      r0,|L1.44|
000012  f7fffffe          BL       USART_ReceiveData
000016  4906              LDR      r1,|L1.48|
000018  6008              STR      r0,[r1,#0]  ; rs485_recv_ch
;;;152    		rs485_recv_flag = 1;
00001a  2001              MOVS     r0,#1
00001c  4905              LDR      r1,|L1.52|
00001e  6008              STR      r0,[r1,#0]  ; rs485_recv_flag
;;;153    		// 清空接收非空中断标志，注意如果不清空中断标志，则无法响应之后的中断
;;;154    		USART_ClearITPendingBit(USART2, USART_IT_RXNE);
000020  f2405125          MOV      r1,#0x525
000024  4801              LDR      r0,|L1.44|
000026  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.42|
;;;155    		//LED0 = !LED0;
;;;156    	}
;;;157    }
00002a  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  |L1.44|
                          DCD      0x40004400
                  |L1.48|
                          DCD      rs485_recv_ch
                  |L1.52|
                          DCD      rs485_recv_flag

                          AREA ||i.rs485_getchar||, CODE, READONLY, ALIGN=2

                  rs485_getchar PROC
;;;87      **/
;;;88     int rs485_getchar(void)
000000  2000              MOVS     r0,#0
;;;89     {
;;;90     	uint16_t ch = 0;
;;;91     
;;;92     	// 切换到接收状态
;;;93     	RS485_CMD(RS485_RECV);
000002  bf00              NOP      
000004  2100              MOVS     r1,#0
000006  4a0b              LDR      r2,|L2.52|
000008  6011              STR      r1,[r2,#0]
00000a  bf00              NOP      
;;;94     	
;;;95     	while (rs485_recv_flag == 0);   // 等待数据
00000c  bf00              NOP      
                  |L2.14|
00000e  490a              LDR      r1,|L2.56|
000010  6809              LDR      r1,[r1,#0]  ; rs485_recv_flag
000012  2900              CMP      r1,#0
000014  d0fb              BEQ      |L2.14|
;;;96     	ch = rs485_recv_ch;    // 读取数据
000016  4909              LDR      r1,|L2.60|
000018  6809              LDR      r1,[r1,#0]  ; rs485_recv_ch
00001a  b288              UXTH     r0,r1
;;;97     	rs485_recv_ch = EOF;   // 清空数据
00001c  f04f31ff          MOV      r1,#0xffffffff
000020  4a06              LDR      r2,|L2.60|
000022  6011              STR      r1,[r2,#0]  ; rs485_recv_ch
;;;98     	rs485_recv_flag = 0;   // 清空标志
000024  2100              MOVS     r1,#0
000026  4a04              LDR      r2,|L2.56|
000028  6011              STR      r1,[r2,#0]  ; rs485_recv_flag
;;;99     
;;;100    	if ('\r' == ch)   // 收到 '\r' 则转换为 '\n'
00002a  280d              CMP      r0,#0xd
00002c  d100              BNE      |L2.48|
;;;101    	{
;;;102    		ch = '\n';
00002e  200a              MOVS     r0,#0xa
                  |L2.48|
;;;103    	}
;;;104    	
;;;105    	// 返回数据
;;;106    	return ch;
;;;107    }
000030  4770              BX       lr
;;;108    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x424302a0
                  |L2.56|
                          DCD      rs485_recv_flag
                  |L2.60|
                          DCD      rs485_recv_ch

                          AREA ||i.rs485_init||, CODE, READONLY, ALIGN=2

                  rs485_init PROC
;;;23      **/
;;;24     void rs485_init(uint32_t baudrate)
000000  b510              PUSH     {r4,lr}
;;;25     {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;26     	GPIO_InitTypeDef GPIO_InitStruct;
;;;27     	USART_InitTypeDef USART_InitStruct;
;;;28     	NVIC_InitTypeDef NVIC_InitStruct;
;;;29     	
;;;30     	// 使能 GPIOA, GPIOG 时钟
;;;31     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOG, ENABLE);
000006  2101              MOVS     r1,#1
000008  2041              MOVS     r0,#0x41
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;32     	
;;;33     	// 使能 USART2 时钟
;;;34     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0448              LSLS     r0,r1,#17
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;35     	
;;;36     	// 设置 PA2, PA3复用为 USART2
;;;37     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
000016  2207              MOVS     r2,#7
000018  2102              MOVS     r1,#2
00001a  482c              LDR      r0,|L3.204|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;38     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
000020  2207              MOVS     r2,#7
000022  2103              MOVS     r1,#3
000024  4829              LDR      r0,|L3.204|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;39     	
;;;40     	// 配置 PA2, PA3
;;;41     	GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_AF;              // 复用功能
00002a  2002              MOVS     r0,#2
00002c  f88d001c          STRB     r0,[sp,#0x1c]
;;;42     	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;             // 推挽
000030  2000              MOVS     r0,#0
000032  f88d001e          STRB     r0,[sp,#0x1e]
;;;43     	GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
000036  200c              MOVS     r0,#0xc
000038  9006              STR      r0,[sp,#0x18]
;;;44     	GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_UP;              // 上拉，高电平空闲
00003a  2001              MOVS     r0,#1
00003c  f88d001f          STRB     r0,[sp,#0x1f]
;;;45     	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
000040  2003              MOVS     r0,#3
000042  f88d001d          STRB     r0,[sp,#0x1d]
;;;46     	GPIO_Init(GPIOA, &GPIO_InitStruct);
000046  a906              ADD      r1,sp,#0x18
000048  4820              LDR      r0,|L3.204|
00004a  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48     	// 配置 PG8
;;;49     	GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_OUT;   // 输出
00004e  2001              MOVS     r0,#1
000050  f88d001c          STRB     r0,[sp,#0x1c]
;;;50     	GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_8;
000054  0200              LSLS     r0,r0,#8
000056  9006              STR      r0,[sp,#0x18]
;;;51     	GPIO_Init(GPIOG, &GPIO_InitStruct);
000058  a906              ADD      r1,sp,#0x18
00005a  481d              LDR      r0,|L3.208|
00005c  f7fffffe          BL       GPIO_Init
;;;52     	
;;;53     	// 配置 USART2
;;;54     	// void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
;;;55     	USART_InitStruct.USART_BaudRate            = baudrate;    // 波特率
000060  9402              STR      r4,[sp,#8]
;;;56     	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  // 无流控
000062  2000              MOVS     r0,#0
000064  f8ad0014          STRH     r0,[sp,#0x14]
;;;57     	USART_InitStruct.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;   // 收发
000068  200c              MOVS     r0,#0xc
00006a  f8ad0012          STRH     r0,[sp,#0x12]
;;;58     	USART_InitStruct.USART_Parity              = USART_Parity_No;           // 无奇偶校验
00006e  2000              MOVS     r0,#0
000070  f8ad0010          STRH     r0,[sp,#0x10]
;;;59     	USART_InitStruct.USART_StopBits            = USART_StopBits_1;          // 1 位停止位
000074  f8ad000e          STRH     r0,[sp,#0xe]
;;;60     	USART_InitStruct.USART_WordLength          = USART_WordLength_8b;       // 8 位数据位
000078  f8ad000c          STRH     r0,[sp,#0xc]
;;;61     	USART_Init(USART2, &USART_InitStruct);
00007c  a902              ADD      r1,sp,#8
00007e  4815              LDR      r0,|L3.212|
000080  f7fffffe          BL       USART_Init
;;;62     
;;;63     	NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn;    // 中断向量表位置
000084  2026              MOVS     r0,#0x26
000086  f88d0004          STRB     r0,[sp,#4]
;;;64     	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;      // 使能 NVIC 中断
00008a  2001              MOVS     r0,#1
00008c  f88d0007          STRB     r0,[sp,#7]
;;;65     	// 优先级数字越小优先级越高
;;;66     	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2;   // 抢占优先级
000090  2002              MOVS     r0,#2
000092  f88d0005          STRB     r0,[sp,#5]
;;;67     	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;   // 响应(子/次)优先级
000096  f88d0006          STRB     r0,[sp,#6]
;;;68     	NVIC_Init(&NVIC_InitStruct);
00009a  a801              ADD      r0,sp,#4
00009c  f7fffffe          BL       NVIC_Init
;;;69     	// void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
;;;70     	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;71     	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;72     	USART_ClearITPendingBit(USART2, USART_IT_RXNE | USART_IT_TXE);   // 清空接收非空中断
0000a0  f2407127          MOV      r1,#0x727
0000a4  480b              LDR      r0,|L3.212|
0000a6  f7fffffe          BL       USART_ClearITPendingBit
;;;73     	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);    // 使能接收非空中断
0000aa  2201              MOVS     r2,#1
0000ac  f2405125          MOV      r1,#0x525
0000b0  4808              LDR      r0,|L3.212|
0000b2  f7fffffe          BL       USART_ITConfig
;;;74     	
;;;75     	// 使能 USART2
;;;76     	// void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
;;;77     	USART_Cmd(USART2, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  4806              LDR      r0,|L3.212|
0000ba  f7fffffe          BL       USART_Cmd
;;;78     	
;;;79     	// 默认为接收状态
;;;80     	RS485_CMD(RS485_RECV);
0000be  bf00              NOP      
0000c0  2000              MOVS     r0,#0
0000c2  4905              LDR      r1,|L3.216|
0000c4  6008              STR      r0,[r1,#0]
0000c6  bf00              NOP      
;;;81     }
0000c8  b008              ADD      sp,sp,#0x20
0000ca  bd10              POP      {r4,pc}
;;;82     
                          ENDP

                  |L3.204|
                          DCD      0x40020000
                  |L3.208|
                          DCD      0x40021800
                  |L3.212|
                          DCD      0x40004400
                  |L3.216|
                          DCD      0x424302a0

                          AREA ||i.rs485_putchar||, CODE, READONLY, ALIGN=2

                  rs485_putchar PROC
;;;113     **/
;;;114    int rs485_putchar(int c)
000000  b510              PUSH     {r4,lr}
;;;115    {
000002  4604              MOV      r4,r0
;;;116    	// 切换到发送状态
;;;117    	RS485_CMD(RS485_SEND);
000004  bf00              NOP      
000006  2001              MOVS     r0,#1
000008  490d              LDR      r1,|L4.64|
00000a  6008              STR      r0,[r1,#0]
00000c  bf00              NOP      
;;;118    	
;;;119    	// 等待可发送数据（即等待发送数据缓冲区为空）
;;;120    	while (RESET == USART_GetFlagStatus(USART2, USART_FLAG_TXE));
00000e  bf00              NOP      
                  |L4.16|
000010  2180              MOVS     r1,#0x80
000012  480c              LDR      r0,|L4.68|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L4.16|
;;;121    	
;;;122    	// 发送数据
;;;123    	USART_SendData(USART2, c);
00001c  b2a1              UXTH     r1,r4
00001e  4809              LDR      r0,|L4.68|
000020  f7fffffe          BL       USART_SendData
;;;124    	
;;;125    	// 等待发送完成
;;;126    	while (RESET == USART_GetFlagStatus(USART2, USART_FLAG_TC));
000024  bf00              NOP      
                  |L4.38|
000026  2140              MOVS     r1,#0x40
000028  4806              LDR      r0,|L4.68|
00002a  f7fffffe          BL       USART_GetFlagStatus
00002e  2800              CMP      r0,#0
000030  d0f9              BEQ      |L4.38|
;;;127    	
;;;128    	// 切换到接收状态
;;;129    	RS485_CMD(RS485_RECV);
000032  bf00              NOP      
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L4.64|
000038  6008              STR      r0,[r1,#0]
00003a  bf00              NOP      
;;;130    	
;;;131    	return c;
00003c  4620              MOV      r0,r4
;;;132    }
00003e  bd10              POP      {r4,pc}
;;;133    
                          ENDP

                  |L4.64|
                          DCD      0x424302a0
                  |L4.68|
                          DCD      0x40004400

                          AREA ||.data||, DATA, ALIGN=2

                  rs485_recv_ch
                          DCD      0xffffffff
                  rs485_recv_flag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\SYSTEM\\SRC\\rs485.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_rs485_c_4bd7811d____REV16|
#line 138 "..\\..\\CORE\\core_cmInstr.h"
|__asm___7_rs485_c_4bd7811d____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_rs485_c_4bd7811d____REVSH|
#line 153
|__asm___7_rs485_c_4bd7811d____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_rs485_c_4bd7811d____RRX|
#line 328
|__asm___7_rs485_c_4bd7811d____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
