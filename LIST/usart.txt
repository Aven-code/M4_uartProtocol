; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\..\obj\usart.o --asm_dir=..\..\LIST\ --list_dir=..\..\LIST\ --depend=..\..\obj\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\..\CORE -I..\..\FWLIB\inc -I..\..\SYSTEM\INC -IF:\粤嵌\课堂演示-粤嵌1914\3_Cortex-M4应用开发\11_I2C总线原理\USER\RTE -IE:\Kile\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IE:\Kile\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\obj\usart.crf ..\..\SYSTEM\SRC\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;156    // USART1 中断处理(服务)函数
;;;157    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159    	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;160    	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;161    	if (SET == USART_GetITStatus(USART1, USART_IT_RXNE))  // 是接收非空中断
000002  f2405125          MOV      r1,#0x525
000006  4809              LDR      r0,|L1.44|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d10c              BNE      |L1.42|
;;;162    	{
;;;163    		usart1_recv_ch = USART_ReceiveData(USART1);
000010  4806              LDR      r0,|L1.44|
000012  f7fffffe          BL       USART_ReceiveData
000016  4906              LDR      r1,|L1.48|
000018  6008              STR      r0,[r1,#0]  ; usart1_recv_ch
;;;164    		usart1_recv_flag = 1;
00001a  2001              MOVS     r0,#1
00001c  4905              LDR      r1,|L1.52|
00001e  6008              STR      r0,[r1,#0]  ; usart1_recv_flag
;;;165    		// 清空接收非空中断标志，注意如果不清空中断标志，则无法响应之后的中断
;;;166    		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
000020  f2405125          MOV      r1,#0x525
000024  4801              LDR      r0,|L1.44|
000026  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.42|
;;;167    		//LED0 = !LED0;
;;;168    	}
;;;169    }
00002a  bd10              POP      {r4,pc}
;;;170    
                          ENDP

                  |L1.44|
                          DCD      0x40011000
                  |L1.48|
                          DCD      usart1_recv_ch
                  |L1.52|
                          DCD      usart1_recv_flag

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;364    
;;;365    void _sys_exit(int return_code) {
000000  bf00              NOP      
                  |L2.2|
;;;366      while (1);    /* endless loop */
000002  e7fe              B        |L2.2|
;;;367    }
;;;368    
                          ENDP


                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;358    
;;;359    void _ttywrch(int ch) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;360      //sendchar (ch);
;;;361    	usart1_putchar(ch);          // 用 usart1 的函数替换
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       usart1_putchar
;;;362    }
00000a  bd10              POP      {r4,pc}
;;;363    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;352    
;;;353    int ferror(FILE *f) {
000000  4601              MOV      r1,r0
;;;354      /* Your implementation of ferror */
;;;355      return EOF;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;356    }
000006  4770              BX       lr
;;;357    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;346    
;;;347    int fgetc(FILE *f) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;348      //return (sendchar(getkey()));
;;;349    	return usart1_getchar();     // 用 usart1 的函数替换
000004  f7fffffe          BL       usart1_getchar
;;;350    }
000008  bd10              POP      {r4,pc}
;;;351    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;341    
;;;342    int fputc(int ch, FILE *f) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;343      //return (sendchar(ch));
;;;344    	return usart1_putchar(ch);   // 用 usart1 的函数替换
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       usart1_putchar
;;;345    }
00000c  bd70              POP      {r4-r6,pc}
;;;346    
                          ENDP


                          AREA ||i.usart1_getchar||, CODE, READONLY, ALIGN=2

                  usart1_getchar PROC
;;;103     **/
;;;104    int usart1_getchar(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	uint16_t ch = 0;
000002  2400              MOVS     r4,#0
;;;107    	
;;;108    #ifdef USART1_USE_INTERRUPT
;;;109    	while (usart1_recv_flag == 0);   // 等待数据
000004  bf00              NOP      
                  |L7.6|
000006  480b              LDR      r0,|L7.52|
000008  6800              LDR      r0,[r0,#0]  ; usart1_recv_flag
00000a  2800              CMP      r0,#0
00000c  d0fb              BEQ      |L7.6|
;;;110    	ch = usart1_recv_ch;    // 读取数据
00000e  480a              LDR      r0,|L7.56|
000010  6800              LDR      r0,[r0,#0]  ; usart1_recv_ch
000012  b284              UXTH     r4,r0
;;;111    	usart1_recv_ch = EOF;   // 清空数据
000014  f04f30ff          MOV      r0,#0xffffffff
000018  4907              LDR      r1,|L7.56|
00001a  6008              STR      r0,[r1,#0]  ; usart1_recv_ch
;;;112    	usart1_recv_flag = 0;   // 清空标志
00001c  2000              MOVS     r0,#0
00001e  4905              LDR      r1,|L7.52|
000020  6008              STR      r0,[r1,#0]  ; usart1_recv_flag
;;;113    #else
;;;114    	// 等待数据（即等待输入数据缓冲区非空）
;;;115    	while (RESET == USART_GetFlagStatus(USART1, USART_FLAG_RXNE));
;;;116    	
;;;117    	// 读取数据
;;;118    	ch = USART_ReceiveData(USART1);
;;;119    #endif
;;;120    	if ('\r' == ch)   // 收到 '\r' 则转换为 '\n'
000022  2c0d              CMP      r4,#0xd
000024  d100              BNE      |L7.40|
;;;121    	{
;;;122    		ch = '\n';
000026  240a              MOVS     r4,#0xa
                  |L7.40|
;;;123    	}
;;;124    	usart1_putchar(ch);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       usart1_putchar
;;;125    	
;;;126    	// 返回数据
;;;127    	return ch;
00002e  4620              MOV      r0,r4
;;;128    }
000030  bd10              POP      {r4,pc}
;;;129    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      usart1_recv_flag
                  |L7.56|
                          DCD      usart1_recv_ch

                          AREA ||i.usart1_init||, CODE, READONLY, ALIGN=2

                  usart1_init PROC
;;;38      **/
;;;39     void usart1_init(uint32_t baudrate)
000000  b510              PUSH     {r4,lr}
;;;40     {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;41     	GPIO_InitTypeDef GPIO_InitStruct;
;;;42     	USART_InitTypeDef USART_InitStruct;
;;;43     #ifdef USART1_USE_INTERRUPT
;;;44     	NVIC_InitTypeDef NVIC_InitStruct;
;;;45     #endif
;;;46     	
;;;47     	// 使能 GPIOA 的时钟
;;;48     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;49     	
;;;50     	// 使能 USART1 的时钟
;;;51     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2010              MOVS     r0,#0x10
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;52     	
;;;53     	// 设置 PA9, PA10 复用为 USART1
;;;54     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000016  2207              MOVS     r2,#7
000018  2109              MOVS     r1,#9
00001a  4826              LDR      r0,|L8.180|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;55     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
000020  2207              MOVS     r2,#7
000022  210a              MOVS     r1,#0xa
000024  4823              LDR      r0,|L8.180|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;56     	
;;;57     	// 配置 PA9, PA10
;;;58     	GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_AF;              // 复用功能
00002a  2002              MOVS     r0,#2
00002c  f88d001c          STRB     r0,[sp,#0x1c]
;;;59     	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;             // 推挽
000030  2000              MOVS     r0,#0
000032  f88d001e          STRB     r0,[sp,#0x1e]
;;;60     	GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_9 | GPIO_Pin_10;
000036  f44f60c0          MOV      r0,#0x600
00003a  9006              STR      r0,[sp,#0x18]
;;;61     	GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_UP;              // 上拉，高电平空闲
00003c  2001              MOVS     r0,#1
00003e  f88d001f          STRB     r0,[sp,#0x1f]
;;;62     	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
000042  2003              MOVS     r0,#3
000044  f88d001d          STRB     r0,[sp,#0x1d]
;;;63     	GPIO_Init(GPIOA, &GPIO_InitStruct);
000048  a906              ADD      r1,sp,#0x18
00004a  481a              LDR      r0,|L8.180|
00004c  f7fffffe          BL       GPIO_Init
;;;64     	
;;;65     	// 配置 USART1
;;;66     	// void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
;;;67     	USART_InitStruct.USART_BaudRate            = baudrate;    // 波特率
000050  9402              STR      r4,[sp,#8]
;;;68     	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  // 无流控
000052  2000              MOVS     r0,#0
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;69     	USART_InitStruct.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;   // 收发
000058  200c              MOVS     r0,#0xc
00005a  f8ad0012          STRH     r0,[sp,#0x12]
;;;70     	USART_InitStruct.USART_Parity              = USART_Parity_No;           // 无奇偶校验
00005e  2000              MOVS     r0,#0
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;71     	USART_InitStruct.USART_StopBits            = USART_StopBits_1;          // 1 位停止位
000064  f8ad000e          STRH     r0,[sp,#0xe]
;;;72     	USART_InitStruct.USART_WordLength          = USART_WordLength_8b;       // 8 位数据位
000068  f8ad000c          STRH     r0,[sp,#0xc]
;;;73     	USART_Init(USART1, &USART_InitStruct);
00006c  a902              ADD      r1,sp,#8
00006e  4812              LDR      r0,|L8.184|
000070  f7fffffe          BL       USART_Init
;;;74     	
;;;75     #ifdef USART1_USE_INTERRUPT
;;;76     	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;    // 中断向量表位置
000074  2025              MOVS     r0,#0x25
000076  f88d0004          STRB     r0,[sp,#4]
;;;77     	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;      // 使能 NVIC 中断
00007a  2001              MOVS     r0,#1
00007c  f88d0007          STRB     r0,[sp,#7]
;;;78     	// 优先级数字越小优先级越高
;;;79     	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2;   // 抢占优先级
000080  2002              MOVS     r0,#2
000082  f88d0005          STRB     r0,[sp,#5]
;;;80     	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;   // 响应(子/次)优先级
000086  f88d0006          STRB     r0,[sp,#6]
;;;81     	NVIC_Init(&NVIC_InitStruct);
00008a  a801              ADD      r0,sp,#4
00008c  f7fffffe          BL       NVIC_Init
;;;82     	// void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
;;;83     	// ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;84     	// void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
;;;85     	USART_ClearITPendingBit(USART1, USART_IT_RXNE);   // 清空接收非空中断
000090  f2405125          MOV      r1,#0x525
000094  4808              LDR      r0,|L8.184|
000096  f7fffffe          BL       USART_ClearITPendingBit
;;;86     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);    // 使能接收非空中断
00009a  2201              MOVS     r2,#1
00009c  f2405125          MOV      r1,#0x525
0000a0  4805              LDR      r0,|L8.184|
0000a2  f7fffffe          BL       USART_ITConfig
;;;87     #endif
;;;88     
;;;89     	// 使能 USART1
;;;90     	// void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
;;;91     	USART_Cmd(USART1, ENABLE);
0000a6  2101              MOVS     r1,#1
0000a8  4803              LDR      r0,|L8.184|
0000aa  f7fffffe          BL       USART_Cmd
;;;92     }
0000ae  b008              ADD      sp,sp,#0x20
0000b0  bd10              POP      {r4,pc}
;;;93     
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      0x40020000
                  |L8.184|
                          DCD      0x40011000

                          AREA ||i.usart1_printf||, CODE, READONLY, ALIGN=1

                  usart1_printf PROC
;;;291     **/
;;;292    int usart1_printf(const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;293    {
000002  b530              PUSH     {r4,r5,lr}
000004  b0a1              SUB      sp,sp,#0x84
;;;294    	va_list ap;
;;;295    	char buf[128] = "", *s = buf;
000006  2180              MOVS     r1,#0x80
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
00000e  466c              MOV      r4,sp
;;;296    	int cnt = 0;
000010  2500              MOVS     r5,#0
;;;297    	
;;;298    	va_start(ap, format);
000012  a825              ADD      r0,sp,#0x94
000014  9020              STR      r0,[sp,#0x80]
;;;299    	cnt = vsnprintf(buf, sizeof buf, format, ap);
000016  2180              MOVS     r1,#0x80
000018  4668              MOV      r0,sp
00001a  9b20              LDR      r3,[sp,#0x80]
00001c  9a24              LDR      r2,[sp,#0x90]
00001e  f7fffffe          BL       __c89vsnprintf
000022  4605              MOV      r5,r0
;;;300    	while (*s)
000024  e003              B        |L9.46|
                  |L9.38|
;;;301    	{
;;;302    		usart1_putchar(*s); s++;
000026  7820              LDRB     r0,[r4,#0]
000028  f7fffffe          BL       usart1_putchar
00002c  1c64              ADDS     r4,r4,#1
                  |L9.46|
00002e  7820              LDRB     r0,[r4,#0]            ;300
000030  2800              CMP      r0,#0                 ;300
000032  d1f8              BNE      |L9.38|
;;;303    	}
;;;304    	va_end(ap);
000034  9020              STR      r0,[sp,#0x80]
;;;305    	
;;;306    	return cnt;
000036  4628              MOV      r0,r5
;;;307    }
000038  b021              ADD      sp,sp,#0x84
00003a  bc30              POP      {r4,r5}
00003c  f85dfb14          LDR      pc,[sp],#0x14
;;;308    
                          ENDP


                          AREA ||i.usart1_putchar||, CODE, READONLY, ALIGN=2

                  usart1_putchar PROC
;;;134     **/
;;;135    int usart1_putchar(int c)
000000  b510              PUSH     {r4,lr}
;;;136    {
000002  4604              MOV      r4,r0
;;;137    	// 等待可发送数据（即等待发送数据缓冲区为空）
;;;138    	while (RESET == USART_GetFlagStatus(USART1, USART_FLAG_TXE));
000004  bf00              NOP      
                  |L10.6|
000006  2180              MOVS     r1,#0x80
000008  4805              LDR      r0,|L10.32|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L10.6|
;;;139    	
;;;140    	// 发送数据
;;;141    	USART_SendData(USART1, c);
000012  b2a1              UXTH     r1,r4
000014  4802              LDR      r0,|L10.32|
000016  f7fffffe          BL       USART_SendData
;;;142    	
;;;143    	return c;
00001a  4620              MOV      r0,r4
;;;144    }
00001c  bd10              POP      {r4,pc}
;;;145    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=2

                  usart1_recv_ch
                          DCD      0xffffffff
                  usart1_recv_flag
                          DCD      0x00000000
                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\SYSTEM\\SRC\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____REV16|
#line 138 "..\\..\\CORE\\core_cmInstr.h"
|__asm___7_usart_c_d693318e____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____REVSH|
#line 153
|__asm___7_usart_c_d693318e____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_d693318e____RRX|
#line 328
|__asm___7_usart_c_d693318e____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
