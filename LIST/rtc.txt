; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\..\obj\rtc.o --asm_dir=..\..\LIST\ --list_dir=..\..\LIST\ --depend=..\..\obj\rtc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\..\CORE -I..\..\FWLIB\inc -I..\..\SYSTEM\INC -IF:\粤嵌\课堂演示-粤嵌1914\3_Cortex-M4应用开发\11_I2C总线原理\USER\RTE -IE:\Kile\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IE:\Kile\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\obj\rtc.crf ..\..\SYSTEM\SRC\rtc.c]
                          THUMB

                          AREA ||i.RTC_Alarm_IRQHandler||, CODE, READONLY, ALIGN=2

                  RTC_Alarm_IRQHandler PROC
;;;428     **/
;;;429    void RTC_Alarm_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;430    {
;;;431    	if (SET == RTC_GetITStatus(RTC_IT_ALRA))
000002  f44f5080          MOV      r0,#0x1000
000006  f7fffffe          BL       RTC_GetITStatus
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L1.24|
;;;432    	{
;;;433    		alarma_flag = 1;
00000e  4911              LDR      r1,|L1.84|
000010  7008              STRB     r0,[r1,#0]
;;;434    		// 清除闹钟 A 标志
;;;435    		RTC_ClearITPendingBit(RTC_IT_ALRA);
000012  0300              LSLS     r0,r0,#12
000014  f7fffffe          BL       RTC_ClearITPendingBit
                  |L1.24|
;;;436    	}
;;;437    	
;;;438    	if (SET == RTC_GetITStatus(RTC_IT_ALRB))
000018  f44f5000          MOV      r0,#0x2000
00001c  f7fffffe          BL       RTC_GetITStatus
000020  2801              CMP      r0,#1
000022  d104              BNE      |L1.46|
;;;439    	{
;;;440    		alarmb_flag = 1;
000024  490c              LDR      r1,|L1.88|
000026  7008              STRB     r0,[r1,#0]
;;;441    		// 清除闹钟 A 标志
;;;442    		RTC_ClearITPendingBit(RTC_IT_ALRB);
000028  0340              LSLS     r0,r0,#13
00002a  f7fffffe          BL       RTC_ClearITPendingBit
                  |L1.46|
;;;443    	}
;;;444    	// 清除中断线 17 标志
;;;445    	EXTI_ClearITPendingBit(EXTI_Line17);
00002e  f44f3000          MOV      r0,#0x20000
000032  f7fffffe          BL       EXTI_ClearITPendingBit
;;;446    	LED0_ON();
000036  bf00              NOP      
000038  f44f7100          MOV      r1,#0x200
00003c  4807              LDR      r0,|L1.92|
00003e  f7fffffe          BL       GPIO_ResetBits
000042  bf00              NOP      
;;;447    	LED3_ON();
000044  bf00              NOP      
000046  f44f4180          MOV      r1,#0x4000
00004a  4805              LDR      r0,|L1.96|
00004c  f7fffffe          BL       GPIO_ResetBits
000050  bf00              NOP      
;;;448    }
000052  bd10              POP      {r4,pc}
;;;449    
                          ENDP

                  |L1.84|
                          DCD      alarma_flag
                  |L1.88|
                          DCD      alarmb_flag
                  |L1.92|
                          DCD      0x40021400
                  |L1.96|
                          DCD      0x40021000

                          AREA ||i.RTC_WKUP_IRQHandler||, CODE, READONLY, ALIGN=2

                  RTC_WKUP_IRQHandler PROC
;;;454     **/
;;;455    void RTC_WKUP_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;456    {
;;;457    	wakeup_flag = 1;
000002  2001              MOVS     r0,#1
000004  4904              LDR      r1,|L2.24|
000006  7008              STRB     r0,[r1,#0]
;;;458    	// 清除闹钟 A 的中断标志
;;;459    	RTC_ClearITPendingBit(RTC_IT_WUT);
000008  0380              LSLS     r0,r0,#14
00000a  f7fffffe          BL       RTC_ClearITPendingBit
;;;460    	// 清除中断线 22 标志
;;;461    	EXTI_ClearITPendingBit(EXTI_Line22);
00000e  f44f0080          MOV      r0,#0x400000
000012  f7fffffe          BL       EXTI_ClearITPendingBit
;;;462    }
000016  bd10              POP      {r4,pc}
                          ENDP

                  |L2.24|
                          DCD      wakeup_flag

                          AREA ||i.rtc_init||, CODE, READONLY, ALIGN=2

                  rtc_init PROC
;;;34      **/
;;;35     ErrorStatus rtc_init(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;36     {
;;;37     	uint32_t count = 0;
000002  2400              MOVS     r4,#0
;;;38     	RTC_InitTypeDef RTC_InitStruct;
;;;39     	
;;;40     	// 使能 PWR 外设时钟
;;;41     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000004  2101              MOVS     r1,#1
000006  0708              LSLS     r0,r1,#28
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;42     	// void        RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
;;;43     	// void        RCC_RTCCLKCmd(FunctionalState NewState);
;;;44     	// 使能备份域访问
;;;45     	// void PWR_BackupAccessCmd(FunctionalState NewState);
;;;46     	PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;47     	
;;;48     	// 使能 RTC 外设时钟
;;;49     	RCC_RTCCLKCmd(ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       RCC_RTCCLKCmd
;;;50     	
;;;51     	// 判断之前是否初始化过了，如果已初始化过了，则直接返回
;;;52     	if (RTC_INITIALIZED_FLAG == RTC_ReadBackupRegister(RTC_INIT_REG))
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       RTC_ReadBackupRegister
00001e  491a              LDR      r1,|L3.136|
000020  4288              CMP      r0,r1
000022  d101              BNE      |L3.40|
;;;53     	{
;;;54     		return SUCCESS;
000024  2001              MOVS     r0,#1
                  |L3.38|
;;;55     	}
;;;56     	
;;;57     	// 开启 LSE 时钟源
;;;58     	// void        RCC_LSEConfig(uint8_t RCC_LSE);
;;;59     	RCC_LSEConfig(RCC_LSE_ON);
;;;60     	
;;;61     	// 等待时钟源就绪，RCC->BDCR 的 [1] 位变为 1
;;;62     	while (!(RCC->BDCR & 0x2) && (count < LSE_READY_TIMEOUT))
;;;63     	{
;;;64     		count++;
;;;65     	}
;;;66     	if (count == LSE_READY_TIMEOUT)  // 超时
;;;67     	{
;;;68     			return ERROR;
;;;69     	}
;;;70     	
;;;71     	// 选择 LSE 作为 RTC 时钟源
;;;72     	// void        RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
;;;73     	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;74     	
;;;75     	// 初始化 RTC
;;;76     	RTC_InitStruct.RTC_AsynchPrediv = 0x7F;
;;;77     	RTC_InitStruct.RTC_SynchPrediv = 0xFF;
;;;78     	RTC_InitStruct.RTC_HourFormat = RTC_HourFormat_24;
;;;79     	// ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
;;;80     	RTC_Init(&RTC_InitStruct);
;;;81     	
;;;82     	// 写入已初始化标志到备份域寄存器
;;;83     	// void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
;;;84     	// 解锁
;;;85     	RTC->WPR = 0xCA;
;;;86       RTC->WPR = 0x53;
;;;87     	RTC_WriteBackupRegister(RTC_INIT_REG, RTC_INITIALIZED_FLAG);
;;;88     	// 加锁
;;;89     	RTC->WPR = 0xFF;
;;;90     	
;;;91     	return SUCCESS;
;;;92     }
000026  bd3e              POP      {r1-r5,pc}
                  |L3.40|
000028  2001              MOVS     r0,#1                 ;59
00002a  f7fffffe          BL       RCC_LSEConfig
00002e  e000              B        |L3.50|
                  |L3.48|
000030  1c64              ADDS     r4,r4,#1              ;64
                  |L3.50|
000032  4816              LDR      r0,|L3.140|
000034  6800              LDR      r0,[r0,#0]            ;62
000036  f0000002          AND      r0,r0,#2              ;62
00003a  b918              CBNZ     r0,|L3.68|
00003c  f06f407f          MVN      r0,#0xff000000        ;62
000040  4284              CMP      r4,r0                 ;62
000042  d3f5              BCC      |L3.48|
                  |L3.68|
000044  f06f407f          MVN      r0,#0xff000000        ;66
000048  4284              CMP      r4,r0                 ;66
00004a  d101              BNE      |L3.80|
00004c  2000              MOVS     r0,#0                 ;68
00004e  e7ea              B        |L3.38|
                  |L3.80|
000050  f44f7080          MOV      r0,#0x100             ;73
000054  f7fffffe          BL       RCC_RTCCLKConfig
000058  207f              MOVS     r0,#0x7f              ;76
00005a  9001              STR      r0,[sp,#4]            ;76
00005c  20ff              MOVS     r0,#0xff              ;77
00005e  9002              STR      r0,[sp,#8]            ;77
000060  2000              MOVS     r0,#0                 ;78
000062  9000              STR      r0,[sp,#0]            ;78
000064  4668              MOV      r0,sp                 ;80
000066  f7fffffe          BL       RTC_Init
00006a  20ca              MOVS     r0,#0xca              ;85
00006c  4908              LDR      r1,|L3.144|
00006e  6008              STR      r0,[r1,#0]            ;85
000070  2053              MOVS     r0,#0x53              ;86
000072  6008              STR      r0,[r1,#0]            ;86
000074  4904              LDR      r1,|L3.136|
000076  2000              MOVS     r0,#0                 ;87
000078  f7fffffe          BL       RTC_WriteBackupRegister
00007c  20ff              MOVS     r0,#0xff              ;89
00007e  4904              LDR      r1,|L3.144|
000080  6008              STR      r0,[r1,#0]            ;89
000082  2001              MOVS     r0,#1                 ;91
000084  e7cf              B        |L3.38|
;;;93     
                          ENDP

000086  0000              DCW      0x0000
                  |L3.136|
                          DCD      0x87654321
                  |L3.140|
                          DCD      0x40023870
                  |L3.144|
                          DCD      0x40002824

                          AREA ||i.rtc_is_alarma||, CODE, READONLY, ALIGN=2

                  rtc_is_alarma PROC
;;;390     **/
;;;391    uint8_t rtc_is_alarma(void)
000000  4902              LDR      r1,|L4.12|
;;;392    {
;;;393    	uint8_t flag = alarma_flag;
000002  7808              LDRB     r0,[r1,#0]  ; alarma_flag
;;;394    	alarma_flag = 0;
000004  2100              MOVS     r1,#0
000006  4a01              LDR      r2,|L4.12|
000008  7011              STRB     r1,[r2,#0]
;;;395    	return flag;
;;;396    }
00000a  4770              BX       lr
;;;397    
                          ENDP

                  |L4.12|
                          DCD      alarma_flag

                          AREA ||i.rtc_is_alarmb||, CODE, READONLY, ALIGN=2

                  rtc_is_alarmb PROC
;;;402     **/
;;;403    uint8_t rtc_is_alarmb(void)
000000  4902              LDR      r1,|L5.12|
;;;404    {
;;;405    	uint8_t flag = alarmb_flag;
000002  7808              LDRB     r0,[r1,#0]  ; alarmb_flag
;;;406    	alarmb_flag = 0;
000004  2100              MOVS     r1,#0
000006  4a01              LDR      r2,|L5.12|
000008  7011              STRB     r1,[r2,#0]
;;;407    	return flag;
;;;408    }
00000a  4770              BX       lr
;;;409    
                          ENDP

                  |L5.12|
                          DCD      alarmb_flag

                          AREA ||i.rtc_is_wakeup||, CODE, READONLY, ALIGN=2

                  rtc_is_wakeup PROC
;;;414     **/
;;;415    uint8_t rtc_is_wakeup(void)
000000  4902              LDR      r1,|L6.12|
;;;416    {
;;;417    	uint8_t flag = wakeup_flag;
000002  7808              LDRB     r0,[r1,#0]  ; wakeup_flag
;;;418    	wakeup_flag = 0;
000004  2100              MOVS     r1,#0
000006  4a01              LDR      r2,|L6.12|
000008  7011              STRB     r1,[r2,#0]
;;;419    	return flag;
;;;420    }
00000a  4770              BX       lr
;;;421    
                          ENDP

                  |L6.12|
                          DCD      wakeup_flag

                          AREA ||i.rtc_print_date_time||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  rtc_print_date_time PROC
;;;144     **/
;;;145    void rtc_print_date_time(void)
000000  b500              PUSH     {lr}
;;;146    {
000002  b087              SUB      sp,sp,#0x1c
;;;147    	RTC_DateTypeDef date;
;;;148    	RTC_TimeTypeDef time;
;;;149    	
;;;150    	/*
;;;151    		中文手册 《23.3.6 读取日历》：
;;;152    		当 RTC_CR 寄存器中的 BYPSHAD 控制位清零时，即从影子寄存器读取日历时，
;;;153    		每次将日历寄存器中的值复制到 RTC_SSR、 RTC_TR 和 RTC_DR 影子寄存器时， 
;;;154    		RTC_ISR 寄存器中的 RSF 位都会置 1。每两个 TRCCLK 周期执行一次复制。为
;;;155    		确保这 3 个值来自同一时刻点，读取 RTC_SSR 或 RTC_TR 时会锁定高阶日历
;;;156    		影子寄存器中的值，直到读取 RTC_DR。
;;;157    		为避免软件对日历执行读访问的时间间隔小于 2 个 RTCCLK 周期：第一次读取
;;;158    		日历之后必须通过软件将 RSF 清零，并且软件必须等待到 RSF 置 1 之后才可
;;;159    		再次读取 RTC_SSR、 RTC_TR 和 RTC_DR	寄存器。
;;;160    		ErrorStatus RTC_WaitForSynchro(void) 函数就是清零 RSF 位并等待其变 1 的
;;;161    	 */
;;;162    	
;;;163    	// 读取日期时间时，必须先读取时间再读日期，否则结果不对
;;;164    	RTC_GetTime(RTC_Format_BIN, &time);
000004  a905              ADD      r1,sp,#0x14
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       RTC_GetTime
;;;165    	RTC_GetDate(RTC_Format_BIN, &date);
00000c  a906              ADD      r1,sp,#0x18
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       RTC_GetDate
;;;166    	
;;;167    	RTC_WaitForSynchro();
000014  f7fffffe          BL       RTC_WaitForSynchro
;;;168    	
;;;169    	printf("%04d-%02d-%02d %02d:%02d:%02d %d", 
000018  f89d0018          LDRB     r0,[sp,#0x18]
00001c  f89d1016          LDRB     r1,[sp,#0x16]
000020  f89d2015          LDRB     r2,[sp,#0x15]
000024  f89d3014          LDRB     r3,[sp,#0x14]
000028  e9cd3200          STRD     r3,r2,[sp,#0]
00002c  e9cd1002          STRD     r1,r0,[sp,#8]
000030  f89d301a          LDRB     r3,[sp,#0x1a]
000034  f89d2019          LDRB     r2,[sp,#0x19]
000038  f89d001b          LDRB     r0,[sp,#0x1b]
00003c  f50061fa          ADD      r1,r0,#0x7d0
000040  a002              ADR      r0,|L7.76|
000042  f7fffffe          BL       __2printf
;;;170    		date.RTC_Year + 2000, date.RTC_Month, date.RTC_Date, 
;;;171    		time.RTC_Hours, time.RTC_Minutes, time.RTC_Seconds,
;;;172    		date.RTC_WeekDay);
;;;173    }
000046  b007              ADD      sp,sp,#0x1c
000048  bd00              POP      {pc}
;;;174    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
00004c  25303464          DCB      "%04d-%02d-%02d %02d:%02d:%02d %d",0
000050  2d253032
000054  642d2530
000058  32642025
00005c  3032643a
000060  25303264
000064  3a253032
000068  64202564
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.rtc_set_alarm||, CODE, READONLY, ALIGN=1

                  rtc_set_alarm PROC
;;;199     **/
;;;200    void rtc_set_alarm(uint32_t RTC_Alarm, uint32_t RTC_AlarmDateWeekDaySel, uint8_t RTC_AlarmDateWeekDay,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;201    	uint8_t RTC_Hours, uint8_t RTC_Minutes, uint8_t RTC_Seconds)
;;;202    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;203    	/*
;;;204    	编程闹钟
;;;205      要对可编程的闹钟（闹钟 A 或闹钟 B）进行编程或更新，必须执行类似的步骤：
;;;206      1. 将 RTC_CR 寄存器中的 ALRAE 或 ALRBE 位清零以禁止闹钟 A 或闹钟 B。
;;;207      2. 轮询 RTC_ISR 寄存器中的 ALRAWF 或 ALRBWF 位，直到其中一个置 1，以确保
;;;208    	   闹钟寄存器可以访问。大约需要 2 个 RTCCLK 时钟周期（由于时钟同步）。
;;;209      3. 编程闹钟 A 或闹钟 B 寄存器（RTC_ALRMASSR/RTC_ALRMAR 或 RTC_ALRMBSSR/
;;;210    	   RTC_ALRMBR）。
;;;211      4. 将 RTC_CR 寄存器中的 ALRAE 或 ALRBE 位置 1 以再次使能闹钟 A 或闹钟 B。
;;;212    	 */
;;;213    	RTC_AlarmTypeDef RTC_AlarmStruct;
;;;214    	
;;;215    	// 禁用闹钟，并等待 RTC 寄存器可访问
;;;216    	RTC_AlarmCmd(RTC_Alarm, DISABLE);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RTC_AlarmCmd
;;;217    	
;;;218    	// 设置闹钟
;;;219    	RTC_AlarmStruct.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel;
000018  9502              STR      r5,[sp,#8]
;;;220    	RTC_AlarmStruct.RTC_AlarmDateWeekDay = RTC_AlarmDateWeekDay;
00001a  f88d700c          STRB     r7,[sp,#0xc]
;;;221    	// 闹钟掩码，指按日期/星期闹，还是小时、分钟、秒等闹，也可以全部匹配闹
;;;222    	// RTC_AlarmMask_None 全部匹配，RTC_AlarmMask_All 全部无关
;;;223    	RTC_AlarmStruct.RTC_AlarmMask = RTC_AlarmMask_None;   // 全部匹配闹
00001e  2000              MOVS     r0,#0
000020  9001              STR      r0,[sp,#4]
;;;224    	RTC_AlarmStruct.RTC_AlarmTime.RTC_Hours = RTC_Hours;
000022  f88d6000          STRB     r6,[sp,#0]
;;;225    	RTC_AlarmStruct.RTC_AlarmTime.RTC_Minutes = RTC_Minutes;
000026  f88d8001          STRB     r8,[sp,#1]
;;;226    	RTC_AlarmStruct.RTC_AlarmTime.RTC_Seconds = RTC_Seconds;
00002a  f88d9002          STRB     r9,[sp,#2]
;;;227    	RTC_AlarmStruct.RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
00002e  f88d0003          STRB     r0,[sp,#3]
;;;228    	RTC_SetAlarm(RTC_Format_BIN, RTC_Alarm, &RTC_AlarmStruct);
000032  466a              MOV      r2,sp
000034  4621              MOV      r1,r4
000036  f7fffffe          BL       RTC_SetAlarm
;;;229    	
;;;230    	// 启用闹钟，并等待 RTC 寄存器可访问
;;;231    	RTC_AlarmCmd(RTC_Alarm, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       RTC_AlarmCmd
;;;232    	// 清除闹钟标志
;;;233    	if (RTC_Alarm == RTC_Alarm_A)  // 闹钟 A
000042  f5b47f80          CMP      r4,#0x100
000046  d104              BNE      |L8.82|
;;;234    	{
;;;235    		RTC_ClearFlag(RTC_FLAG_ALRAF);
000048  f44f7080          MOV      r0,#0x100
00004c  f7fffffe          BL       RTC_ClearFlag
000050  e003              B        |L8.90|
                  |L8.82|
;;;236    	}
;;;237    	else   // 闹钟 B    
;;;238    	{
;;;239    		RTC_ClearFlag(RTC_FLAG_ALRBF);
000052  f44f7000          MOV      r0,#0x200
000056  f7fffffe          BL       RTC_ClearFlag
                  |L8.90|
;;;240    	}
;;;241    	
;;;242    }
00005a  e8bd87ff          POP      {r0-r10,pc}
;;;243    
                          ENDP


                          AREA ||i.rtc_set_alarm_int||, CODE, READONLY, ALIGN=1

                  rtc_set_alarm_int PROC
;;;250     **/
;;;251    void rtc_set_alarm_int(uint32_t RTC_Alarm)
000000  b53e              PUSH     {r1-r5,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253    	/*
;;;254    	要使能 RTC 闹钟中断，需按照以下顺序操作：
;;;255    	1. 将 EXTI 线 17 配置为中断模式并将其使能，然后选择上升沿有效。
;;;256    	2. 配置 NVIC 中的 RTC_Alarm IRQ 通道并将其使能。
;;;257    	3. 配置 RTC 以生成 RTC 闹钟
;;;258    	
;;;259    	RTC_ITConfig(RTC_IT_ALRA, ENABLE);
;;;260    	// 清除闹钟 A 的中断标志
;;;261    	RTC_ClearITPendingBit(RTC_IT_ALRA);（闹钟 A 或闹钟 B）。
;;;262    	 */
;;;263    	EXTI_InitTypeDef EXTI_InitStruct;
;;;264    	NVIC_InitTypeDef NVIC_InitStruct;
;;;265    	
;;;266    	// 清除 EXTI 17 中断线中断标志
;;;267    	EXTI_ClearITPendingBit(EXTI_Line17);
000004  f44f3000          MOV      r0,#0x20000
000008  f7fffffe          BL       EXTI_ClearITPendingBit
;;;268    	
;;;269    	// 配置 EXTI 17 中断
;;;270    	EXTI_InitStruct.EXTI_Line = EXTI_Line17;
00000c  f44f3000          MOV      r0,#0x20000
000010  9001              STR      r0,[sp,#4]
;;;271    	EXTI_InitStruct.EXTI_LineCmd = ENABLE;
000012  2001              MOVS     r0,#1
000014  f88d000a          STRB     r0,[sp,#0xa]
;;;272    	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
000018  2000              MOVS     r0,#0
00001a  f88d0008          STRB     r0,[sp,#8]
;;;273    	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;
00001e  2008              MOVS     r0,#8
000020  f88d0009          STRB     r0,[sp,#9]
;;;274    	EXTI_Init(&EXTI_InitStruct);
000024  a801              ADD      r0,sp,#4
000026  f7fffffe          BL       EXTI_Init
;;;275    	
;;;276    	// 配置 NVIC 
;;;277    	NVIC_InitStruct.NVIC_IRQChannel = RTC_Alarm_IRQn;
00002a  2029              MOVS     r0,#0x29
00002c  f88d0000          STRB     r0,[sp,#0]
;;;278    	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;
000030  2001              MOVS     r0,#1
000032  f88d0001          STRB     r0,[sp,#1]
;;;279    	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;
000036  2002              MOVS     r0,#2
000038  f88d0002          STRB     r0,[sp,#2]
;;;280    	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
00003c  2001              MOVS     r0,#1
00003e  f88d0003          STRB     r0,[sp,#3]
;;;281    	NVIC_Init(&NVIC_InitStruct);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;282    
;;;283    	if (RTC_Alarm == RTC_Alarm_A)  // 闹钟 A
000048  f5b47f80          CMP      r4,#0x100
00004c  d108              BNE      |L9.96|
;;;284    	{
;;;285    		// 使能 RTC 闹钟中断
;;;286    		RTC_ITConfig(RTC_IT_ALRA, ENABLE);
00004e  2101              MOVS     r1,#1
000050  0308              LSLS     r0,r1,#12
000052  f7fffffe          BL       RTC_ITConfig
;;;287    		// 清除闹钟 A 的中断标志
;;;288    		RTC_ClearITPendingBit(RTC_IT_ALRA);
000056  f44f5080          MOV      r0,#0x1000
00005a  f7fffffe          BL       RTC_ClearITPendingBit
00005e  e007              B        |L9.112|
                  |L9.96|
;;;289    	}
;;;290    	else   // 闹钟 B
;;;291    	{
;;;292    		// 使能 RTC 闹钟中断
;;;293    		RTC_ITConfig(RTC_IT_ALRB, ENABLE);
000060  2101              MOVS     r1,#1
000062  0348              LSLS     r0,r1,#13
000064  f7fffffe          BL       RTC_ITConfig
;;;294    		// 清除闹钟 A 的中断标志
;;;295    		RTC_ClearITPendingBit(RTC_IT_ALRB);
000068  f44f5000          MOV      r0,#0x2000
00006c  f7fffffe          BL       RTC_ClearITPendingBit
                  |L9.112|
;;;296    	}
;;;297    }
000070  bd3e              POP      {r1-r5,pc}
;;;298    
                          ENDP


                          AREA ||i.rtc_set_date||, CODE, READONLY, ALIGN=1

                  rtc_set_date PROC
;;;127     **/
;;;128    ErrorStatus rtc_set_date(uint32_t year, uint32_t mon, uint32_t date, uint32_t weekday)
000000  b5f8              PUSH     {r3-r7,lr}
;;;129    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;130    	RTC_DateTypeDef RTC_DateStruct;
;;;131    
;;;132    	RTC_DateStruct.RTC_Year = year % 100;
00000a  2064              MOVS     r0,#0x64
00000c  fbb4f1f0          UDIV     r1,r4,r0
000010  fb004011          MLS      r0,r0,r1,r4
000014  f88d0003          STRB     r0,[sp,#3]
;;;133    	RTC_DateStruct.RTC_Month = mon;
000018  b2e8              UXTB     r0,r5
00001a  f88d0001          STRB     r0,[sp,#1]
;;;134    	RTC_DateStruct.RTC_Date = date;
00001e  b2f0              UXTB     r0,r6
000020  f88d0002          STRB     r0,[sp,#2]
;;;135    	RTC_DateStruct.RTC_WeekDay = weekday;
000024  b2f8              UXTB     r0,r7
000026  f88d0000          STRB     r0,[sp,#0]
;;;136    	// ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
;;;137    	return RTC_SetDate(RTC_Format_BIN, &RTC_DateStruct);
00002a  4669              MOV      r1,sp
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RTC_SetDate
;;;138    }
000032  bdf8              POP      {r3-r7,pc}
;;;139    
                          ENDP


                          AREA ||i.rtc_set_time||, CODE, READONLY, ALIGN=1

                  rtc_set_time PROC
;;;100     **/
;;;101    ErrorStatus rtc_set_time(uint32_t hour, uint32_t min, uint32_t sec)
000000  b5f8              PUSH     {r3-r7,lr}
;;;102    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;103    	RTC_TimeTypeDef RTC_TimeStruct;
;;;104    	
;;;105    	RTC_TimeStruct.RTC_H12 = RTC_H12_AM;
000008  2000              MOVS     r0,#0
00000a  f88d0003          STRB     r0,[sp,#3]
;;;106    	RTC_TimeStruct.RTC_Hours = hour;
00000e  b2e0              UXTB     r0,r4
000010  f88d0000          STRB     r0,[sp,#0]
;;;107    	RTC_TimeStruct.RTC_Minutes = min;
000014  b2e8              UXTB     r0,r5
000016  f88d0001          STRB     r0,[sp,#1]
;;;108    	RTC_TimeStruct.RTC_Seconds = sec;
00001a  b2f0              UXTB     r0,r6
00001c  f88d0002          STRB     r0,[sp,#2]
;;;109    	// ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
;;;110    	return RTC_SetTime(RTC_Format_BIN, &RTC_TimeStruct);
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       RTC_SetTime
;;;111    }
000028  bdf8              POP      {r3-r7,pc}
;;;112    
                          ENDP


                          AREA ||i.rtc_set_wakeup||, CODE, READONLY, ALIGN=1

                  rtc_set_wakeup PROC
;;;310     **/
;;;311    void rtc_set_wakeup(uint32_t RTC_WakeUpCounter, uint32_t RTC_WakeUpClock)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;313    	/*
;;;314    	编程唤醒定时器
;;;315    	要配置或更改唤醒定时器的自动重载值（RTC_WUTR 中的 WUT[15:0]），需要按照以下顺序操作：
;;;316    	1. 清零 RTC_CR 中的 WUTE 以禁止唤醒定时器。
;;;317    	2. 轮询 RTC_ISR 中的 WUTWF，直到该位置 1，以确保可以访问唤醒自动重载
;;;318    	   定时器和 WUCKSEL[2:0] 位。大约需要 2 个 RTCCLK 时钟周期（由于时钟同步）。
;;;319    	3. 编程唤醒自动重载值 WUT[15:0]，并选择唤醒时钟（RTC_CR 中的 WUCKSEL[2:0] 位）。
;;;320    	   将 RTC_CR 寄存器中的 WUTE 位置 1 以再次使能定时器。唤醒定时器重新开始递减
;;;321    	   计数。
;;;322    	 */
;;;323    	//void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
;;;324    	//void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
;;;325    	//uint32_t RTC_GetWakeUpCounter(void);
;;;326    	//ErrorStatus RTC_WakeUpCmd(FunctionalState NewState);
;;;327    	// 禁止唤醒定时器
;;;328    	RTC_WakeUpCmd(DISABLE);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       RTC_WakeUpCmd
;;;329    	
;;;330    	// 设置唤醒自动重载值
;;;331    	RTC_SetWakeUpCounter(RTC_WakeUpCounter);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       RTC_SetWakeUpCounter
;;;332    	
;;;333    	// 选择唤醒时钟
;;;334    	RTC_WakeUpClockConfig(RTC_WakeUpClock);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RTC_WakeUpClockConfig
;;;335    	
;;;336    	// 使能唤醒定时器
;;;337    	RTC_WakeUpCmd(ENABLE);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       RTC_WakeUpCmd
;;;338    	
;;;339    	// 清除唤醒标志
;;;340    	RTC_ClearFlag(RTC_FLAG_WUTF);
00001e  f44f6080          MOV      r0,#0x400
000022  f7fffffe          BL       RTC_ClearFlag
;;;341    }
000026  bd70              POP      {r4-r6,pc}
;;;342    
                          ENDP


                          AREA ||i.rtc_set_wakeup_int||, CODE, READONLY, ALIGN=1

                  rtc_set_wakeup_int PROC
;;;347     **/
;;;348    void rtc_set_wakeup_int(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;349    {
;;;350    	/*
;;;351    	要使能 RTC 唤醒中断，需按照以下顺序操作：
;;;352    	1. 将 EXTI 线 22 配置为中断模式并将其使能，然后选择上升沿有效。
;;;353    	2. 配置 NVIC 中的 RTC_WKUP IRQ 通道并将其使能。
;;;354    	3. 配置 RTC 以生成 RTC 唤醒定时器事件。
;;;355    	 */
;;;356    	EXTI_InitTypeDef EXTI_InitStruct;
;;;357    	NVIC_InitTypeDef NVIC_InitStruct;
;;;358    	
;;;359    	// 清除 EXTI 22 中断线中断标志
;;;360    	EXTI_ClearITPendingBit(EXTI_Line22);
000002  f44f0080          MOV      r0,#0x400000
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;361    	
;;;362    	// 配置 EXTI 22 中断线
;;;363    	EXTI_InitStruct.EXTI_Line = EXTI_Line22;
00000a  f44f0080          MOV      r0,#0x400000
00000e  9001              STR      r0,[sp,#4]
;;;364    	EXTI_InitStruct.EXTI_LineCmd = ENABLE;
000010  2001              MOVS     r0,#1
000012  f88d000a          STRB     r0,[sp,#0xa]
;;;365    	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
000016  2000              MOVS     r0,#0
000018  f88d0008          STRB     r0,[sp,#8]
;;;366    	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;
00001c  2008              MOVS     r0,#8
00001e  f88d0009          STRB     r0,[sp,#9]
;;;367    	EXTI_Init(&EXTI_InitStruct);
000022  a801              ADD      r0,sp,#4
000024  f7fffffe          BL       EXTI_Init
;;;368    	
;;;369    	// 配置 NVIC
;;;370    	NVIC_InitStruct.NVIC_IRQChannel = RTC_WKUP_IRQn;
000028  2003              MOVS     r0,#3
00002a  f88d0000          STRB     r0,[sp,#0]
;;;371    	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
00002e  2001              MOVS     r0,#1
000030  f88d0003          STRB     r0,[sp,#3]
;;;372    	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;
000034  f88d0001          STRB     r0,[sp,#1]
;;;373    	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 3;
000038  2003              MOVS     r0,#3
00003a  f88d0002          STRB     r0,[sp,#2]
;;;374    	NVIC_Init(&NVIC_InitStruct);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       NVIC_Init
;;;375    	
;;;376    	// 使能 RTC 闹钟中断
;;;377    	RTC_ITConfig(RTC_IT_WUT, ENABLE);
000044  2101              MOVS     r1,#1
000046  0388              LSLS     r0,r1,#14
000048  f7fffffe          BL       RTC_ITConfig
;;;378    	// 清除闹钟 A 的中断标志
;;;379    	RTC_ClearITPendingBit(RTC_IT_WUT);
00004c  f44f4080          MOV      r0,#0x4000
000050  f7fffffe          BL       RTC_ClearITPendingBit
;;;380    }
000054  bd0e              POP      {r1-r3,pc}
;;;381    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  alarma_flag
000000  00                DCB      0x00
                  alarmb_flag
000001  00                DCB      0x00
                  wakeup_flag
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\SYSTEM\\SRC\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_rtc_init____REV16|
#line 138 "..\\..\\CORE\\core_cmInstr.h"
|__asm___5_rtc_c_rtc_init____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_rtc_init____REVSH|
#line 153
|__asm___5_rtc_c_rtc_init____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_rtc_init____RRX|
#line 328
|__asm___5_rtc_c_rtc_init____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
