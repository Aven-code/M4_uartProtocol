; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\..\obj\delay.o --asm_dir=..\..\LIST\ --list_dir=..\..\LIST\ --depend=..\..\obj\delay.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\..\CORE -I..\..\FWLIB\inc -I..\..\SYSTEM\INC -IF:\粤嵌\课堂演示-粤嵌1914\3_Cortex-M4应用开发\11_I2C总线原理\USER\RTE -IE:\Kile\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IE:\Kile\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\obj\delay.crf ..\..\SYSTEM\SRC\delay.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;83     // 10ms 为单位延时
;;;84     void Delay(__IO uint32_t nTime)
000000  b501              PUSH     {r0,lr}
;;;85     {
;;;86     	delay_ms(nTime * 10);
000002  9900              LDR      r1,[sp,#0]
000004  eb010181          ADD      r1,r1,r1,LSL #2
000008  0048              LSLS     r0,r1,#1
00000a  f7fffffe          BL       delay_ms
;;;87     }
00000e  bd08              POP      {r3,pc}
;;;88     
                          ENDP


                          AREA ||i.TimingDelay_Decrement||, CODE, READONLY, ALIGN=2

                  TimingDelay_Decrement PROC
;;;109      */
;;;110    void TimingDelay_Decrement(void)
000000  4804              LDR      r0,|L2.20|
;;;111    {
;;;112      if (uwTimingDelay != 0x00)
000002  6800              LDR      r0,[r0,#0]  ; uwTimingDelay
000004  b120              CBZ      r0,|L2.16|
;;;113      { 
;;;114        uwTimingDelay--;
000006  4803              LDR      r0,|L2.20|
000008  6800              LDR      r0,[r0,#0]  ; uwTimingDelay
00000a  1e40              SUBS     r0,r0,#1
00000c  4901              LDR      r1,|L2.20|
00000e  6008              STR      r0,[r1,#0]  ; uwTimingDelay
                  |L2.16|
;;;115      }
;;;116    }
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      uwTimingDelay

                          AREA ||i._delay_us||, CODE, READONLY, ALIGN=2

                  _delay_us PROC
;;;40      **/
;;;41     static void _delay_us(uint32_t nus)
000000  490f              LDR      r1,|L3.64|
;;;42     {
;;;43     	SysTick->LOAD = nus * fac_us - 1;
000002  6809              LDR      r1,[r1,#0]  ; fac_us
000004  4341              MULS     r1,r0,r1
000006  1e49              SUBS     r1,r1,#1
000008  f04f22e0          MOV      r2,#0xe000e000
00000c  6151              STR      r1,[r2,#0x14]
;;;44       SysTick->VAL  = 0UL;
00000e  2100              MOVS     r1,#0
000010  6191              STR      r1,[r2,#0x18]
;;;45     	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
000012  4611              MOV      r1,r2
000014  6909              LDR      r1,[r1,#0x10]
000016  f0410101          ORR      r1,r1,#1
00001a  6111              STR      r1,[r2,#0x10]
;;;46     	while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != SysTick_CTRL_COUNTFLAG_Msk);
00001c  bf00              NOP      
                  |L3.30|
00001e  f04f21e0          MOV      r1,#0xe000e000
000022  6909              LDR      r1,[r1,#0x10]
000024  f4013180          AND      r1,r1,#0x10000
000028  f5b13f80          CMP      r1,#0x10000
00002c  d1f7              BNE      |L3.30|
;;;47     	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
00002e  f04f21e0          MOV      r1,#0xe000e000
000032  6909              LDR      r1,[r1,#0x10]
000034  f0210101          BIC      r1,r1,#1
000038  f04f22e0          MOV      r2,#0xe000e000
00003c  6111              STR      r1,[r2,#0x10]
;;;48     }
00003e  4770              BX       lr
;;;49     
                          ENDP

                  |L3.64|
                          DCD      fac_us

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;71      **/
;;;72     void delay_ms(uint32_t nms)
000000  b570              PUSH     {r4-r6,lr}
;;;73     {
000002  4604              MOV      r4,r0
;;;74     	uint32_t ms = (1 << 24) / fac_us / 1000;  // 每次能延时的最大毫秒数
000004  480d              LDR      r0,|L4.60|
000006  6800              LDR      r0,[r0,#0]  ; fac_us
000008  f04f7180          MOV      r1,#0x1000000
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f5f1          UDIV     r5,r0,r1
;;;75     	while (nms >= ms)
000018  e006              B        |L4.40|
                  |L4.26|
;;;76     	{
;;;77     		_delay_us(ms * 1000);
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fb05f001          MUL      r0,r5,r1
000022  f7fffffe          BL       _delay_us
;;;78     		nms -= ms;
000026  1b64              SUBS     r4,r4,r5
                  |L4.40|
000028  42ac              CMP      r4,r5                 ;75
00002a  d2f6              BCS      |L4.26|
;;;79     	}
;;;80     	_delay_us(nms * 1000);
00002c  f44f717a          MOV      r1,#0x3e8
000030  fb04f001          MUL      r0,r4,r1
000034  f7fffffe          BL       _delay_us
;;;81     }
000038  bd70              POP      {r4-r6,pc}
;;;82     
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      fac_us

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;54      **/
;;;55     void delay_us(uint32_t nus)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  4605              MOV      r5,r0
;;;57     	uint32_t us = (1 << 24) / fac_us;  // 每次能延时的最大微秒数
000004  4808              LDR      r0,|L5.40|
000006  6800              LDR      r0,[r0,#0]  ; fac_us
000008  f04f7180          MOV      r1,#0x1000000
00000c  fbb1f4f0          UDIV     r4,r1,r0
;;;58     	
;;;59     	while (nus >= us)
000010  e003              B        |L5.26|
                  |L5.18|
;;;60     	{
;;;61     		_delay_us(us);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _delay_us
;;;62     		nus -= us;
000018  1b2d              SUBS     r5,r5,r4
                  |L5.26|
00001a  42a5              CMP      r5,r4                 ;59
00001c  d2f9              BCS      |L5.18|
;;;63     	}
;;;64     	_delay_us(nus);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       _delay_us
;;;65     }
000024  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      fac_us

                          AREA ||i.systick_init||, CODE, READONLY, ALIGN=2

                  systick_init PROC
;;;16      **/
;;;17     void systick_init(uint32_t systick_clksrc)
000000  b51f              PUSH     {r0-r4,lr}
;;;18     {
000002  4604              MOV      r4,r0
;;;19     	RCC_ClocksTypeDef RCC_Clocks;
;;;20     	
;;;21     	RCC_GetClocksFreq(&RCC_Clocks);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       RCC_GetClocksFreq
;;;22     	SysTick->LOAD  = 0UL;
00000a  2000              MOVS     r0,#0
00000c  f04f21e0          MOV      r1,#0xe000e000
000010  6148              STR      r0,[r1,#0x14]
;;;23       SysTick->VAL   = 0UL;
000012  6188              STR      r0,[r1,#0x18]
;;;24     	if (systick_clksrc == SysTick_CLKSource_HCLK)
000014  2c04              CMP      r4,#4
000016  d108              BNE      |L6.42|
;;;25     	{
;;;26     		SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk;   // 选择 AHB 作为时钟源
000018  2004              MOVS     r0,#4
00001a  6108              STR      r0,[r1,#0x10]
;;;27     		fac_us = RCC_Clocks.HCLK_Frequency / 1000000;  // 得到 us 延时因子
00001c  4908              LDR      r1,|L6.64|
00001e  9801              LDR      r0,[sp,#4]
000020  fbb0f0f1          UDIV     r0,r0,r1
000024  4907              LDR      r1,|L6.68|
000026  6008              STR      r0,[r1,#0]  ; fac_us
000028  e009              B        |L6.62|
                  |L6.42|
;;;28     	}
;;;29     	else
;;;30     	{
;;;31     		SysTick->CTRL  = 0;   // 选择 AHB / 8 作为时钟源
00002a  2000              MOVS     r0,#0
00002c  f04f21e0          MOV      r1,#0xe000e000
000030  6108              STR      r0,[r1,#0x10]
;;;32     		fac_us = RCC_Clocks.HCLK_Frequency / 8000000;  // 得到 us 延时因子
000032  4905              LDR      r1,|L6.72|
000034  9801              LDR      r0,[sp,#4]
000036  fbb0f0f1          UDIV     r0,r0,r1
00003a  4902              LDR      r1,|L6.68|
00003c  6008              STR      r0,[r1,#0]  ; fac_us
                  |L6.62|
;;;33     	}
;;;34     }
00003e  bd1f              POP      {r0-r4,pc}
;;;35     
                          ENDP

                  |L6.64|
                          DCD      0x000f4240
                  |L6.68|
                          DCD      fac_us
                  |L6.72|
                          DCD      0x007a1200

                          AREA ||.data||, DATA, ALIGN=2

                  uwTimingDelay
                          DCD      0x00000000
                  fac_us
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\SYSTEM\\SRC\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_fac_us____REV16|
#line 138 "..\\..\\CORE\\core_cmInstr.h"
|__asm___7_delay_c_fac_us____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_fac_us____REVSH|
#line 153
|__asm___7_delay_c_fac_us____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_fac_us____RRX|
#line 328
|__asm___7_delay_c_fac_us____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
