; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\..\obj\spi.o --asm_dir=..\..\LIST\ --list_dir=..\..\LIST\ --depend=..\..\obj\spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\..\CORE -I..\..\FWLIB\inc -I..\..\SYSTEM\INC -IF:\粤嵌\课堂演示-粤嵌1914\3_Cortex-M4应用开发\13_IWDG独立看门狗\USER\RTE -IE:\Kile\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -IE:\Kile\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\obj\spi.crf ..\..\SYSTEM\SRC\spi.c]
                          THUMB

                          AREA ||i.spi1_init||, CODE, READONLY, ALIGN=2

                  spi1_init PROC
;;;32      **/
;;;33     void spi1_init(uint16_t baudrate)
000000  b510              PUSH     {r4,lr}
;;;34     {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;35     	GPIO_InitTypeDef GPIO_InitStruct;
;;;36     	SPI_InitTypeDef SPI_InitStruct;
;;;37     	
;;;38     	// 使能 GPIOB, PGIOG 时钟
;;;39     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOG, ENABLE);
000006  2101              MOVS     r1,#1
000008  2042              MOVS     r0,#0x42
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;40     	
;;;41     	// 使能 SPI1 时钟
;;;42     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0308              LSLS     r0,r1,#12
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;43     	
;;;44     	// 配置 PB3, PB4, PB5 复用为 SPI1
;;;45     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
000016  2205              MOVS     r2,#5
000018  2103              MOVS     r1,#3
00001a  482e              LDR      r0,|L1.212|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;46     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
000020  2205              MOVS     r2,#5
000022  2104              MOVS     r1,#4
000024  482b              LDR      r0,|L1.212|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;47     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
00002a  2205              MOVS     r2,#5
00002c  4611              MOV      r1,r2
00002e  4829              LDR      r0,|L1.212|
000030  f7fffffe          BL       GPIO_PinAFConfig
;;;48     	
;;;49     	// 配置 PB3, PB4, PB5
;;;50     	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
000034  2002              MOVS     r0,#2
000036  f88d001c          STRB     r0,[sp,#0x1c]
;;;51     	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
00003a  2000              MOVS     r0,#0
00003c  f88d001e          STRB     r0,[sp,#0x1e]
;;;52     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
000040  2038              MOVS     r0,#0x38
000042  9006              STR      r0,[sp,#0x18]
;;;53     	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
000044  2001              MOVS     r0,#1
000046  f88d001f          STRB     r0,[sp,#0x1f]
;;;54     	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
00004a  2003              MOVS     r0,#3
00004c  f88d001d          STRB     r0,[sp,#0x1d]
;;;55     	GPIO_Init(GPIOB, &GPIO_InitStruct);
000050  a906              ADD      r1,sp,#0x18
000052  4820              LDR      r0,|L1.212|
000054  f7fffffe          BL       GPIO_Init
;;;56     	
;;;57     	// 配置 PB14
;;;58     	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
000058  2001              MOVS     r0,#1
00005a  f88d001c          STRB     r0,[sp,#0x1c]
;;;59     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;
00005e  0380              LSLS     r0,r0,#14
000060  9006              STR      r0,[sp,#0x18]
;;;60     	GPIO_Init(GPIOB, &GPIO_InitStruct);
000062  a906              ADD      r1,sp,#0x18
000064  481b              LDR      r0,|L1.212|
000066  f7fffffe          BL       GPIO_Init
;;;61     	
;;;62     	// 配置 PG7
;;;63     	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
00006a  2001              MOVS     r0,#1
00006c  f88d001c          STRB     r0,[sp,#0x1c]
;;;64     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_7;
000070  2080              MOVS     r0,#0x80
000072  9006              STR      r0,[sp,#0x18]
;;;65     	GPIO_Init(GPIOG, &GPIO_InitStruct);
000074  a906              ADD      r1,sp,#0x18
000076  4818              LDR      r0,|L1.216|
000078  f7fffffe          BL       GPIO_Init
;;;66     	
;;;67     	// 配置 SPI1
;;;68     	SPI_InitStruct.SPI_BaudRatePrescaler = baudrate;
00007c  f8ad4010          STRH     r4,[sp,#0x10]
;;;69     	// W25Q128 支持 模式0/模式3，这里配置为 模式0
;;;70     	// 模式0：CPOL CPHA = 00
;;;71     	// 模式1：CPOL CPHA = 01
;;;72     	// 模式2：CPOL CPHA = 10
;;;73     	// 模式3：CPOL CPHA = 11
;;;74     	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;    // 第一个边沿 0
000080  2000              MOVS     r0,#0
000082  f8ad000c          STRH     r0,[sp,#0xc]
;;;75     	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;      // 低电平空闲 0
000086  f8ad000a          STRH     r0,[sp,#0xa]
;;;76     	SPI_InitStruct.SPI_CRCPolynomial = 7;        // CRC 校验多项式
00008a  2007              MOVS     r0,#7
00008c  f8ad0014          STRH     r0,[sp,#0x14]
;;;77     	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;   // 8 位数据
000090  2000              MOVS     r0,#0
000092  f8ad0008          STRH     r0,[sp,#8]
;;;78     	SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  // 双线全双工
000096  f8ad0004          STRH     r0,[sp,#4]
;;;79     	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;   // MSB 先发送
00009a  f8ad0012          STRH     r0,[sp,#0x12]
;;;80     	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;   // 主模式
00009e  f44f7082          MOV      r0,#0x104
0000a2  f8ad0006          STRH     r0,[sp,#6]
;;;81     	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;       // 软件管理从模式选择
0000a6  f44f7000          MOV      r0,#0x200
0000aa  f8ad000e          STRH     r0,[sp,#0xe]
;;;82     	SPI_Init(SPI1, &SPI_InitStruct);
0000ae  a901              ADD      r1,sp,#4
0000b0  480a              LDR      r0,|L1.220|
0000b2  f7fffffe          BL       SPI_Init
;;;83     	
;;;84     	// 使能 SPI1
;;;85     	SPI_Cmd(SPI1, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  4808              LDR      r0,|L1.220|
0000ba  f7fffffe          BL       SPI_Cmd
;;;86     	
;;;87     	// 禁用所有外设
;;;88     	W25Q128_DISABLE();
0000be  bf00              NOP      
0000c0  2001              MOVS     r0,#1
0000c2  4907              LDR      r1,|L1.224|
0000c4  6008              STR      r0,[r1,#0]
0000c6  bf00              NOP      
;;;89     	NRF24L01_DISABLE();
0000c8  bf00              NOP      
0000ca  4906              LDR      r1,|L1.228|
0000cc  6008              STR      r0,[r1,#0]
0000ce  bf00              NOP      
;;;90     }
0000d0  b008              ADD      sp,sp,#0x20
0000d2  bd10              POP      {r4,pc}
;;;91     
                          ENDP

                  |L1.212|
                          DCD      0x40020400
                  |L1.216|
                          DCD      0x40021800
                  |L1.220|
                          DCD      0x40013000
                  |L1.224|
                          DCD      0x424082b8
                  |L1.228|
                          DCD      0x4243029c

                          AREA ||i.spi1_w25q128_read_id||, CODE, READONLY, ALIGN=2

                  spi1_w25q128_read_id PROC
;;;142     **/
;;;143    uint16_t spi1_w25q128_read_id(void)
000000  b510              PUSH     {r4,lr}
;;;144    {
;;;145    	uint16_t id = 0;
000002  2400              MOVS     r4,#0
;;;146    	
;;;147    	// 片选
;;;148    	W25Q128_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  490e              LDR      r1,|L2.68|
00000a  6008              STR      r0,[r1,#0]
00000c  bf00              NOP      
;;;149    	
;;;150    	// 发送读 ID 指令
;;;151    	spi1_w25q128_read_write_byte(W25Q128_ID);
00000e  2090              MOVS     r0,#0x90
000010  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;152    
;;;153    	// 发送 3 个字节的 0 address
;;;154    	spi1_w25q128_read_write_byte(0x00);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;155    	spi1_w25q128_read_write_byte(0x00);
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;156    	spi1_w25q128_read_write_byte(0x00);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;157    	// 接收制造商 ID 
;;;158    	id = spi1_w25q128_read_write_byte(W25Q128_DUMMY) << 8;
000026  20ff              MOVS     r0,#0xff
000028  f7fffffe          BL       spi1_w25q128_read_write_byte
00002c  0204              LSLS     r4,r0,#8
;;;159    	// 接收设备 ID
;;;160    	id |= spi1_w25q128_read_write_byte(W25Q128_DUMMY) & 0xFF;
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       spi1_w25q128_read_write_byte
000034  4304              ORRS     r4,r4,r0
;;;161    	
;;;162    	// 取消片选
;;;163    	W25Q128_DISABLE();
000036  bf00              NOP      
000038  2001              MOVS     r0,#1
00003a  4902              LDR      r1,|L2.68|
00003c  6008              STR      r0,[r1,#0]
00003e  bf00              NOP      
;;;164    	
;;;165    	return id;
000040  4620              MOV      r0,r4
;;;166    }
000042  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L2.68|
                          DCD      0x424082b8

                          AREA ||i.spi1_w25q128_read_sr1||, CODE, READONLY, ALIGN=2

                  spi1_w25q128_read_sr1 PROC
;;;174     **/
;;;175    uint8_t spi1_w25q128_read_sr1(void)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177    	uint8_t sr1 = 0;
000002  2400              MOVS     r4,#0
;;;178    	
;;;179    	// 片选
;;;180    	W25Q128_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  4908              LDR      r1,|L3.44|
00000a  6008              STR      r0,[r1,#0]
00000c  bf00              NOP      
;;;181    	
;;;182    	// 发送 读状态寄存器 1 命令
;;;183    	spi1_w25q128_read_write_byte(W25Q128_SR1);
00000e  2005              MOVS     r0,#5
000010  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;184    	sr1 = spi1_w25q128_read_write_byte(W25Q128_DUMMY);
000014  20ff              MOVS     r0,#0xff
000016  f7fffffe          BL       spi1_w25q128_read_write_byte
00001a  4604              MOV      r4,r0
;;;185    	
;;;186    	// 片选
;;;187    	W25Q128_DISABLE();
00001c  bf00              NOP      
00001e  2001              MOVS     r0,#1
000020  4902              LDR      r1,|L3.44|
000022  6008              STR      r0,[r1,#0]
000024  bf00              NOP      
;;;188    	
;;;189    	return sr1;
000026  4620              MOV      r0,r4
;;;190    }
000028  bd10              POP      {r4,pc}
;;;191    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x424082b8

                          AREA ||i.spi1_w25q128_read_write_byte||, CODE, READONLY, ALIGN=2

                  spi1_w25q128_read_write_byte PROC
;;;125     **/
;;;126    uint8_t spi1_w25q128_read_write_byte(uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128    	// void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
;;;129    	// uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
;;;130    	// 等待发送非空
;;;131    	while (RESET == SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE));
000004  bf00              NOP      
                  |L4.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L4.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L4.6|
;;;132    	SPI_I2S_SendData(SPI1, data);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L4.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;133    	// 等待接收非空
;;;134    	while (RESET == SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE));
00001a  bf00              NOP      
                  |L4.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L4.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L4.28|
;;;135    	return SPI_I2S_ReceiveData(SPI1);//如果是接受就返回数据
000028  4802              LDR      r0,|L4.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;136    }
000030  bd10              POP      {r4,pc}
;;;137    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x40013000

                          AREA ||i.spi1_w25q128_write_disable||, CODE, READONLY, ALIGN=2

                  spi1_w25q128_write_disable PROC
;;;218     **/
;;;219    void spi1_w25q128_write_disable(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221    	// 片选
;;;222    	W25Q128_ENABLE();
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  4906              LDR      r1,|L5.32|
000008  6008              STR      r0,[r1,#0]
00000a  bf00              NOP      
;;;223    	
;;;224    	// 发送 写禁用 命令
;;;225    	spi1_w25q128_read_write_byte(W25Q128_WD);
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;226    	
;;;227    	// 片选
;;;228    	W25Q128_DISABLE();
000012  bf00              NOP      
000014  2001              MOVS     r0,#1
000016  4902              LDR      r1,|L5.32|
000018  6008              STR      r0,[r1,#0]
00001a  bf00              NOP      
;;;229    }
00001c  bd10              POP      {r4,pc}
;;;230    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      0x424082b8

                          AREA ||i.spi1_w25q128_write_enable||, CODE, READONLY, ALIGN=2

                  spi1_w25q128_write_enable PROC
;;;198     **/
;;;199    void spi1_w25q128_write_enable(void)
000000  b510              PUSH     {r4,lr}
;;;200    {
;;;201    	// 片选
;;;202    	W25Q128_ENABLE();
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  4906              LDR      r1,|L6.32|
000008  6008              STR      r0,[r1,#0]
00000a  bf00              NOP      
;;;203    	
;;;204    	// 发送 写使能 命令
;;;205    	spi1_w25q128_read_write_byte(W25Q128_WEL);
00000c  2006              MOVS     r0,#6
00000e  f7fffffe          BL       spi1_w25q128_read_write_byte
;;;206    	
;;;207    	// 片选
;;;208    	W25Q128_DISABLE();
000012  bf00              NOP      
000014  2001              MOVS     r0,#1
000016  4902              LDR      r1,|L6.32|
000018  6008              STR      r0,[r1,#0]
00001a  bf00              NOP      
;;;209    }
00001c  bd10              POP      {r4,pc}
;;;210    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x424082b8

;*** Start embedded assembler ***

#line 1 "..\\..\\SYSTEM\\SRC\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_0f0cc462____REV16|
#line 138 "..\\..\\CORE\\core_cmInstr.h"
|__asm___5_spi_c_0f0cc462____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_0f0cc462____REVSH|
#line 153
|__asm___5_spi_c_0f0cc462____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_0f0cc462____RRX|
#line 328
|__asm___5_spi_c_0f0cc462____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
